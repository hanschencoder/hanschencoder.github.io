---
layout: post
title:  Git使用和介绍-基础指令
tags:
- git
- git使用教程
categories:
- Git
---

参考文档：[Pro Git（中文版）][1]

git已经越来越常用了，但是很多用惯了svn的童鞋使用git的时候，一开始对git应该不太习惯，比如我~~，但是用习惯了之后，发现git还真是好用，哈哈。git的使用和介绍分为两篇，第一篇将一些基础的指令和概念，第二篇讲git分支。下面就整理了一些git常用的命令：

# 查看已有配置
```
 git config --list 
```

<!-- more -->

# 取消已有的配置
```
 git config --global --unset user.name
```


# 设置用户名
```
 git config --global user.name "your name"
 git config --global user.email "your_email@youremail.com" 
```

# 设置代理
```
 git config --global http.sslverify false
 git config --global http.proxy http://192.168.0.24:808
 git config --global https.proxy http://192.168.0.24:808
```

# 文件状态

![image_1aobam36t1slv493cei7r13r39.png-36.1kB][2]
了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区staged)、本地仓库和远程仓库。

 - 未跟踪（untracked）：表示此文件尚未纳入版本控制管理（使用add指令可把文件添加到staged状态）
 - 已修改（modified）：表示修改了某个文件，但还没有提交保存（使用add指令可把文件添加到staged状态）
 - 已暂存（staged）：表示把已修改的文件放在下次提交时要保存的清单中（使用commit命令可把staged中的提交到本地代码仓库HEAD中）
 - 已提交（committed）：表示该文件已经被安全地保存在本地数据库中了  

![image_1aobb3po5pvubtd1pnht8ppi7t.png-43.3kB][3]

> 要确定哪些文件当前处于什么状态，可以用 git status 命令
 

# 如何创建代码仓库
有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来

 - 在工作目录中初始化新仓库：git init。初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中
 - 从现有仓库克隆： git clone [url]。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字，如：git clone git://github.com/schacon/grit.git mygrit

# 忽略某些文件
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式
```
*.[oa]
*~
#第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件
```
文件 .gitignore 的格式规范如下：

 - 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略
 - 可以使用标准的 glob 模式匹配
 - 匹配模式最后跟反斜杠（/）说明要忽略的是目录
 - 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反

# 查看已暂存和未暂存的更新
 - git diff：是查看working tree与暂存区index的差别的，也就是修改之后还没有暂存起来的变化内容
 - git diff --cached：查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异。
 - git diff HEAD：显示工作版本(Working tree)和HEAD的差别

# 提交更新
在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit。另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新，如：
```
git commit -m "Story 182: Fix benchmarks for speed"
```

# 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤
```
$ git status
    # On branch master
    #
    # Changes not staged for commit:
    #
    # modified: benchmarks.rb
    #
$ git commit -a -m 'added new benchmarks'
    [master 83e38c7] added new benchmarks
    1 files changed, 5 insertions(+), 0 deletions(-)
    
# 看到了吗？提交之前不再需要 git add 文件 benchmarks.rb 了,直接被提交了
```

# 移除文件
要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了
```
git rm grit.gemspec
# 注意，执行git rm会把working index的文件也一起删除，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。

git rm -f grit.gemspec
# 即使grit.gemspec文件有修改，也会强行删除文件

git rm --cached grit.gemspec
# 不会删除working index中的文件
```

# 移动文件
```
git mv file_from file_to
```
其实，运行 git mv 就相当于运行了下面三条命令：
```
$ mv README.txt README
$ git rm README.txt
$ git add README
```

# 查看提交历史
```
git log
git log -p -2
# 我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新
```

# 撤消操作
任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果

## 修改最后一次提交
```
git commit --amend
# 把此次commit提交到上一个快照当中，若要增减文件，就先把修改提交到stage区域后再执行git commit --amend。此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样
```

## 取消已经暂存的文件
```
git reset HEAD benchmarks.rb
# add的反操作
```

## 取消对文件的修改
```
git checkout -- benchmarks.rb
# 相当于svn的revert，从index恢复到working

git checkout HEAD -- benchmarks.rb
# 相当于svn的revert，从HEAD恢复到index和working。working和index的内容都将被恢复为HEAD
```

# 远程仓库的使用
## 查看当前的远程库
要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库
```
git remote
git remote -v
# 也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址
```

## 添加远程仓库
![image_1aobtvkmolqs1cui3libfl1gah1a.png-13.7kB][4]
要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]，以新增githuh仓库为栗子。**shortname可以用来指代url**
```
echo "# dd" >> README.md
git init #初始化所在目录为git目录
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/shensky711/dd.git 
#origin为shortname， https://github.com/shensky711/dd.git是url
git push -u origin master
#把本地仓库推送到远程仓库
```

## 从远程仓库抓取数据
此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟
```
git fetch [remote-name]
# 并不会合并数据到当前工作分区

git pull
# git pull <远程主机名> <远程分支名>:<本地分支名>，git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并
# 如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支
```
如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，**fetch 命令只是将远端的数据拉到本地仓库**，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并


## 推送数据到远程仓库
项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]
```
git push origin master
# 把本地的 master 分支推送到 origin 服务器上
```
只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送

## 查看远程仓库信息
```
git remote show [remote-name]

```

## 远程仓库的删除和重命名
```
git remote rename pb paul
# 重命名

git remote rm paul
# 删除
```

# 打标签
## 列出当前的tag列表
```
git tag
# 显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重
```

## 新建标签
创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：
```
git tag -a v1.4 -m 'my version 1.4'
# -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中
```

## 分享标签
默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可
```
git push origin v1.5
# 推送v1.5标签

git push origin --tags
# 推送所有标签
```


 
 
 


















 


  [1]: http://git.oschina.net/progit/
  [2]: http://static.zybuluo.com/shensky711/vj6jn0gxpzrn1tar8sqwb5el/image_1aobam36t1slv493cei7r13r39.png
  [3]: http://static.zybuluo.com/shensky711/9mv9nahib4vph96c4pz51e8g/image_1aobb3po5pvubtd1pnht8ppi7t.png
  [4]: http://static.zybuluo.com/shensky711/2b199e5811j3kc53h3qehuak/image_1aobtvkmolqs1cui3libfl1gah1a.png


 
 