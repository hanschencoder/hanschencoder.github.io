<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HansChen 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.hanschen.site/"/>
  <updated>2021-11-02T07:46:25.289Z</updated>
  <id>http://blog.hanschen.site/</id>
  
  <author>
    <name>chenhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 12 - WMS 层级结构 &amp;&amp; DisplayAreaGroup 引入</title>
    <link href="http://blog.hanschen.site/2021/10/26/android-12-wms-hierarchy/"/>
    <id>http://blog.hanschen.site/2021/10/26/android-12-wms-hierarchy/</id>
    <published>2021-10-25T16:00:00.000Z</published>
    <updated>2021-11-02T07:46:25.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在 Android 窗口管理中，所有的窗口都是以树形数据结构进行组织管理的，认知这棵 WMS 的树有助于我们理解窗口的管理和显示，同时，WMS 的层级也决定了其在 <code>SurfaceFlinger</code> 的层级结构，这恰恰决定了它的显示规则。</p><h1 id="2-WMS-顶层层级构建"><a href="#2-WMS-顶层层级构建" class="headerlink" title="2. WMS 顶层层级构建"></a>2. WMS 顶层层级构建</h1><p>在 Android 12 中，所有窗口树形管理都继基于 <code>WindowContainer，</code> 每个 <code>WindowContainer</code> 都有一个父节点和若干个子节点，我们先看看框架中 <code>WindowContainer</code> 都有哪些类型：</p><p><img src="http://image.hanschen.site/master/2021-11-01-10-50-30.png" alt="2021-11-01-10-50-30"></p><ul><li>RootWindowContainer： 最顶层的管理者，直接管理 DisplayContent</li><li>DisplayContent： 代表着一个真实或者虚拟的显示设备，在普遍场景中，系统中只存在一个 DisplayContent</li><li>TaskDisplayArea： 是系统中所有应用任务的父节点，用于管理 Task</li><li>Task： 代表着一个任务</li><li>ActivityRecord： 代表一个 Activity 节点</li><li>WallpaperWindowToken： 代表壁纸节点</li><li>…</li></ul><a id="more"></a><p>在开始之前大概整理了一下系统中各个节点之间的关系： </p><p><img src="http://image.hanschen.site/master/2021-11-01-11-35-41.png" alt="2021-11-01-11-35-41"></p><p>从上图可以看到，节点之间的嵌套关系还是比较复杂的（ 而且这还是不包括下面章节中提到的引入 Feature 之后的层级关系），层级的最顶端就是 <code>RootWindowContainer，</code> 而它的子节点只能是： <code>DisplayContent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RootWindowContainer.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManagerService wm)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Display[] displays = mDisplayManager.getDisplays();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; displays.length; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> Display display = displays[displayNdx];</span><br><span class="line">        <span class="comment">// 为每一个 Display 挂载一个 DisplayContent 节点</span></span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = <span class="keyword">new</span> DisplayContent(display, <span class="keyword">this</span>);</span><br><span class="line">        addChild(displayContent, POSITION_BOTTOM);</span><br><span class="line">        <span class="keyword">if</span> (displayContent.mDisplayId == DEFAULT_DISPLAY) &#123;</span><br><span class="line">            mDefaultDisplay = displayContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 <code>DisplayContent</code> 的构造方法，核心逻辑就只有一句，依靠 <code>DisplayAreaPolicy</code> 进行层级初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayContent.java</span></span><br><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    <span class="keyword">super</span>(root.mWindowManager, <span class="string">"DisplayContent"</span>, FEATURE_ROOT);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造子节点层级，默认策略是使用 DisplayAreaPolicy.DefaultProvider</span></span><br><span class="line">    mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">            mWmService, <span class="keyword">this</span> <span class="comment">/* content */</span>, <span class="keyword">this</span> <span class="comment">/* root */</span>, mImeWindowsContainer);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayAreaPolicy.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultProvider</span> <span class="keyword">implements</span> <span class="title">DisplayAreaPolicy</span>.<span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DisplayAreaPolicy <span class="title">instantiate</span><span class="params">(WindowManagerService wmService,</span></span></span><br><span class="line"><span class="function"><span class="params">            DisplayContent content, RootDisplayArea root,</span></span></span><br><span class="line"><span class="function"><span class="params">            DisplayArea.Tokens imeContainer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 TaskDisplayArea 节点，注意，这里是允许创建多个 TaskDisplayArea 并添加的</span></span><br><span class="line">        <span class="keyword">final</span> TaskDisplayArea defaultTaskDisplayArea = <span class="keyword">new</span> TaskDisplayArea(content, wmService,</span><br><span class="line">                <span class="string">"DefaultTaskDisplayArea"</span>, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">        <span class="keyword">final</span> List&lt;TaskDisplayArea&gt; tdaList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tdaList.add(defaultTaskDisplayArea);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HierarchyBuilder rootHierarchy = <span class="keyword">new</span> HierarchyBuilder(root);</span><br><span class="line">        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</span><br><span class="line">        <span class="keyword">if</span> (content.isTrusted()) &#123;</span><br><span class="line">            <span class="comment">// 配置 Feature 及它所能影响的层级</span></span><br><span class="line">            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据配置的 Feature  生成并挂载各个节点，建造层级</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 12 上，<code>Feature</code> 正式派上用场了，原生添加了以下 <code>Feature：</code></p><ul><li>WindowedMagnification: 屏幕放大功能，通過 SystemUI mirrorSurface 该节点实现内容拷贝，详见 <code>WindowMagnificationGestureHandler#toggleMagnification</code></li><li>HideDisplayCutout</li><li>OneHandedBackgroundPanel</li><li>OneHanded</li><li>FullscreenMagnification： 屏幕放大功能，通过无障碍服务 <code>FullScreenMagnificationController.SpecAnimationBridge#setMagnificationSpecLocked</code> 最后调用 <code>DisplayContent#applyMagnificationSpec</code> 方法实现节点放大。不过源码中并不是通过这个 Feature 来实现相关层级放大的，改造得还不彻底</li><li>ImePlaceholder</li></ul><p>我们知道，Android 系统是有 Z 轴概念的，不同的窗口有不同的高度，所有的窗口类型对应到 WMS 都会有一个 layer 值，layer 越大，显示在越上面，WMS 规定 1~36 层级，每一个 <code>Feature</code> 都指定了它所能影响到的 layer 层。这里用颜色对不同 <code>Feature</code> 能影响 layer 图层进行颜色标记：</p><p><img src="http://image.hanschen.site/master/2021-11-01-14-35-46.png" alt="2021-11-01-14-35-46"></p><p>标记完之后，就需要根据图表生成窗口层级了，首先对标记好的图表进行上移，上移规则： 如果色块上方是空白的，则可以上移，直至上方是颜色块（不知道大家有没有玩过 2048 这款游戏，上移逻辑是一样的~）</p><p><img src="http://image.hanschen.site/master/2021-11-01-14-45-24.png" alt="2021-11-01-14-45-24"></p><p>上移之后，我们得到了最终的图表，接下来用以下规则进行层级构建：</p><ul><li>同一行相邻的同色块变成一个 <code>Feature</code> 节点，从左到右根据颜色不断生成节点，同一行所有节点挂在同一个父节点下</li><li>父节点就是垂直正上方一行的色块对应的节点</li><li>为最末端所有 <code>Feature</code> 节点再添加一个节点，根据子节点代表的 layer 不一样，最后添加的节点也不一样<ul><li>除了 layer 是 2、15 和 16 外，挂载 <code>DisplayArea.Tokens</code>（这类节点后续只能添加 <code>WindowToken</code> 节点）</li><li>layer = 2 （也就是 <code>APPLICATION_LAYER</code>）的节点，挂载 <code>TaskDisplayArea</code></li><li>layer 等于 15 和 16 的节点，挂载 <code>ImeContainer</code> </li></ul></li></ul><p>通过上述构建规则后，我们可以获得一个树形的层级，并且这棵树有以下特点： </p><ul><li>树的最末端节点对应一个 layer 范围，同一个 layer 值只有一个末端节点与之对应</li><li>为所有 <code>Feature</code> 都生成了对应的父节点，用以控制其所能影响的 layer</li></ul><p>生成了这棵树后，我们会保存两样东西：</p><ul><li>所有 layer 值对应的最末端节点，方便我们后续根据窗口类型添加节点</li><li>以 <code>Map&lt;Feature, List&lt;DisplayArea&gt;&gt;</code>  形式保存的所有 <code>Feature</code> 节点，方便我们后取出某 <code>Feature</code> 对应的所有节点</li></ul><p>现在，虽说我们的 WMS 层级是构建好了，但对于这些 <code>Feature</code> 有何作用还完全没有涉及，这块打算放在 <code>WM Shell</code> 专题里进行说明~~</p><h1 id="3-DisplayAreaGroup"><a href="#3-DisplayAreaGroup" class="headerlink" title="3. DisplayAreaGroup"></a>3. DisplayAreaGroup</h1><p>通过上面 <code>Feature</code> 的说明可以知道，不同的 <code>Feature</code> 是父子节点的关系，那如果我想划分一个逻辑显示区域，对这块区域配置不同的 <code>Feature</code> 该如何呢？ 这时候就可以使用 <code>DisplayAreaGroup</code> 了，框架允许我们添加多个 <code>DisplayAreaGroup，</code> 并为其配置不同的 <code>Feature</code>。</p><p>就像原生提供的 demo 一样，我们可以创建两个 <code>DisplayAreaGroup</code> 并将屏幕一分为二分别放置这两个，这两个区域都是可以作为应用容器的，和分屏不一样的是，这两块区域可以有不同的 Feature 规则以及其他特性，比如设置不同的 <code>DisplayArea#setIgnoreOrientationRequest</code> 值</p><p><img src="http://image.hanschen.site/master/2021-11-01-15-35-28.png" alt="2021-11-01-15-35-28"></p><p><code>DisplayAreaGroup</code> 和 <code>DisplayContent</code> 都是 <code>RootDisplayArea</code> 的直接子类，<code>DisplayAreaGroup</code> 可以认为是一个 Display 划分出的多个<code>逻辑 Display</code> 吧。当然，AOSP 虽然引入了这个概念和代码，但其实并未使用，我们只能从测试代码 <code>DualDisplayAreaGroupPolicyTest</code> 中略窥一二了~      </p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>WMS 相关的内容体系实在太多，本文也仅仅是分析 WMS 窗口层级最顶层的结构，对于具体的窗口添加移除管理这些尚未涉及，同样，原生新增的 Feature 节点使用也没有涉及（这大部分都被打包进 WM Shell 中去了）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;在 Android 窗口管理中，所有的窗口都是以树形数据结构进行组织管理的，认知这棵 WMS 的树有助于我们理解窗口的管理和显示，同时，WMS 的层级也决定了其在 &lt;code&gt;SurfaceFlinger&lt;/code&gt; 的层级结构，这恰恰决定了它的显示规则。&lt;/p&gt;
&lt;h1 id=&quot;2-WMS-顶层层级构建&quot;&gt;&lt;a href=&quot;#2-WMS-顶层层级构建&quot; class=&quot;headerlink&quot; title=&quot;2. WMS 顶层层级构建&quot;&gt;&lt;/a&gt;2. WMS 顶层层级构建&lt;/h1&gt;&lt;p&gt;在 Android 12 中，所有窗口树形管理都继基于 &lt;code&gt;WindowContainer，&lt;/code&gt; 每个 &lt;code&gt;WindowContainer&lt;/code&gt; 都有一个父节点和若干个子节点，我们先看看框架中 &lt;code&gt;WindowContainer&lt;/code&gt; 都有哪些类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.hanschen.site/master/2021-11-01-10-50-30.png&quot; alt=&quot;2021-11-01-10-50-30&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RootWindowContainer： 最顶层的管理者，直接管理 DisplayContent&lt;/li&gt;
&lt;li&gt;DisplayContent： 代表着一个真实或者虚拟的显示设备，在普遍场景中，系统中只存在一个 DisplayContent&lt;/li&gt;
&lt;li&gt;TaskDisplayArea： 是系统中所有应用任务的父节点，用于管理 Task&lt;/li&gt;
&lt;li&gt;Task： 代表着一个任务&lt;/li&gt;
&lt;li&gt;ActivityRecord： 代表一个 Activity 节点&lt;/li&gt;
&lt;li&gt;WallpaperWindowToken： 代表壁纸节点&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="Android 12" scheme="http://blog.hanschen.site/tags/Android-12/"/>
    
      <category term="Android S" scheme="http://blog.hanschen.site/tags/Android-S/"/>
    
  </entry>
  
  <entry>
    <title>Android 12 - 跟踪利器 WinScope</title>
    <link href="http://blog.hanschen.site/2021/10/22/android-12-winscope/"/>
    <id>http://blog.hanschen.site/2021/10/22/android-12-winscope/</id>
    <published>2021-10-21T16:00:00.000Z</published>
    <updated>2021-11-02T06:58:44.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在开发过程中，经常会遇到各种各样的窗口问题，比如动画异常、窗口异常、闪屏、黑屏、错位显示..</p><p>以前对于这些问题，我们可以通过添加日志，调试分析代码等手段去解决，但这些 UI 问题往往出现在一瞬间，很难把握出现的时机，录制下来的日志往往也是巨大的，从海量的日志中提取有效的信息是一个枯燥且繁琐的事情。</p><p>Android 也意识到了这个问题，<code>WinScope</code> 的出现有效的帮助我们跟踪窗口和显示问题。它向开发者提供一个可视化的工具，让开发者能使用工具跟踪整个界面的变化过程，让我们可以观察到细微的变化。迭代了几个版本后，Android 12 上 WinScope 变得更好用了，下面来看看大概的效果：</p><p><img src="http://image.hanschen.site/master/2021-10-22-14-26-57.png" alt="2021-10-22-14-26-57"></p><a id="more"></a><h1 id="2-工具获取"><a href="#2-工具获取" class="headerlink" title="2. 工具获取"></a>2. 工具获取</h1><p>Android 12 平台的 <code>WinScope</code> 工具可以通过源码编译获得，具体也可以查阅 <code>development/tools/winscope</code> 目录下的 README.md 文档，这里提供一个 Ubuntu 平台的编译步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="built_in">cd</span> development/tools/winscope</span><br><span class="line">2. sudo apt install nodejs npm</span><br><span class="line">3. npm install -g yarn</span><br><span class="line">4. yarn install</span><br><span class="line">5. yarn build</span><br></pre></td></tr></table></figure><p>编译过程中遇到一个问题，看上去是在执行 kotlin 优化的时候，报了个内存不足的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.OutOfMemoryError: GC overhead <span class="built_in">limit</span> exceeded</span><br><span class="line">at com.google.gwt.dev.js.ScopeContext.referenceFor(ScopeContext.kt:68)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapAsPropertyNameRef(JsAstMapper.java:247)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapGetProp(JsAstMapper.java:608)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapWithoutLocation(JsAstMapper.java:138)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.map(JsAstMapper.java:47)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapExpression(JsAstMapper.java:466)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapBinaryOperation(JsAstMapper.java:304)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapAssignmentVariant(JsAstMapper.java:258)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.mapWithoutLocation(JsAstMapper.java:102)</span><br><span class="line">at com.google.gwt.dev.js.JsAstMapper.map(JsAstMapper.java:47)</span><br></pre></td></tr></table></figure><p>可以在执行 yarn build 前通过 <code>export JAVA_OPTS=&quot;-XX:-UseGCOverheadLimit&quot;</code> 禁用掉 <code>GC overhead limit exceeded</code> 检测</p><p>编译完之后，在当前目录下会一个 <code>dist</code> 目录，再把 <code>adb_proxy/winscope_proxy.py</code>(一个帮我们开启 trace 抓取命令的脚本，这样我们就可以告别繁琐的命令啦)，文件也拷贝进 <code>dist</code> 目录方便我们后面使用</p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><p>使用比较简单了，连接手机后： </p><ul><li>双击打开 <code>dist</code> 目录下的 <code>index.html</code> 文件</li><li>在终端执行 <code>python3 winscope_proxy.py</code></li></ul><p>PS： 这里建议大家可以设置个 alias 一键使用，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> winscope_s=<span class="string">"xdg-open ~/tools/winscope_s/index.html &amp;&amp; python3 ~/tools/winscope_s/winscope_proxy.py"</span></span><br></pre></td></tr></table></figure><p>输入 python 命令后，终端可能会生成一个 <code>token</code> ，把它复制到浏览器即可</p><p>接下来就会出现下面这个界面：</p><p><img src="http://image.hanschen.site/master/2021-10-22-14-32-16.png" alt="2021-10-22-14-32-16"></p><p>在选择 <code>START TRACE</code> 之后，就可以在手机端进行录制操作，操作完后结束录制即可</p><h1 id="4-功能改进"><a href="#4-功能改进" class="headerlink" title="4. 功能改进"></a>4. 功能改进</h1><p>相比与 Android 11，新的 <code>WinScope</code> 工具在界面上更友好了，重要的改进如下：</p><ul><li>时间线控制更加方便了，可以选择不同类型的时间线用于控制，否则像以前录制了 <code>ProtoLog</code> 后，通过箭头控制时间推移简直是太难用了</li><li>新的 <code>Transaction</code> 和 <code>Log</code> 浏览界面</li><li>支持 Diff 功能，不得不说每一帧的参数太多了，如果没有 diff 功能，实在很难一眼看出那些参数发生了变化</li><li>新增了 IME 的录制，可以录制 <code>InputMethodService</code>、<code>InputMethodManagerService</code> 和 <code>Client</code> 的事件</li><li>录屏界面可以以 PIP 形式显示在浏览器界面上</li><li>…</li></ul><p>不得不说确实比以前好用一些，赶紧尝尝鲜吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;在开发过程中，经常会遇到各种各样的窗口问题，比如动画异常、窗口异常、闪屏、黑屏、错位显示..&lt;/p&gt;
&lt;p&gt;以前对于这些问题，我们可以通过添加日志，调试分析代码等手段去解决，但这些 UI 问题往往出现在一瞬间，很难把握出现的时机，录制下来的日志往往也是巨大的，从海量的日志中提取有效的信息是一个枯燥且繁琐的事情。&lt;/p&gt;
&lt;p&gt;Android 也意识到了这个问题，&lt;code&gt;WinScope&lt;/code&gt; 的出现有效的帮助我们跟踪窗口和显示问题。它向开发者提供一个可视化的工具，让开发者能使用工具跟踪整个界面的变化过程，让我们可以观察到细微的变化。迭代了几个版本后，Android 12 上 WinScope 变得更好用了，下面来看看大概的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.hanschen.site/master/2021-10-22-14-26-57.png&quot; alt=&quot;2021-10-22-14-26-57&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="Android 12" scheme="http://blog.hanschen.site/tags/Android-12/"/>
    
      <category term="Android S" scheme="http://blog.hanschen.site/tags/Android-S/"/>
    
  </entry>
  
  <entry>
    <title>Android 12 - Letterbox 模式</title>
    <link href="http://blog.hanschen.site/2021/10/21/android-12-letterbox/"/>
    <id>http://blog.hanschen.site/2021/10/21/android-12-letterbox/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-11-02T06:58:00.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>随着越来越多大屏和折叠屏设备出现，很多应用并未对不同尺寸的设备进行 UI 适配，这时候应用选择以特定的宽高比显示（<strong>虽然 Google 不建议这这样做，官方还是希望开发者可以对不同的屏幕尺寸进行自适应布局~</strong>），当应用的宽高比和它的容器比例不兼容的时候，就会以 Letterbox 模式打开。</p><p><img src="http://image.hanschen.site/master/2021-10-21-18-17-07.png" alt="2021-10-21-18-17-07"></p><p>Letterbox 模式下界面会以指定的比例显示，周围空白区域可以填充壁纸或者颜色。至于 Letterbox 的外观可受以下因素影响：</p><ul><li><code>config_letterboxActivityCornersRadius</code>： 界面圆角大小</li><li><code>config_letterboxBackgroundType</code>： 背景填充类型，分别有： <ul><li><code>LETTERBOX_BACKGROUND_APP_COLOR_BACKGROUND</code>： 颜色受 <code>android:colorBackground</code> 影响</li><li><code>LETTERBOX_BACKGROUND_APP_COLOR_BACKGROUND_FLOATING</code>： 颜色受 <code>android:colorBackgroundFloating</code> 影响</li><li><code>LETTERBOX_BACKGROUND_SOLID_COLOR</code>： 颜色受 <code>config_letterboxBackgroundColor</code> 影响</li><li><code>LETTERBOX_BACKGROUND_WALLPAPER</code>： 显示壁纸，此选项和 <code>FLAG_SHOW_WALLPAPER</code> 类似，会导致壁纸窗口显示</li></ul></li><li><code>config_letterboxBackgroundWallpaperBlurRadius</code>： 壁纸模糊程度</li><li><code>config_letterboxBackgroundWallaperDarkScrimAlpha</code>： 壁纸变暗程度</li></ul><a id="more"></a><h1 id="2-何时触发"><a href="#2-何时触发" class="headerlink" title="2. 何时触发"></a>2. 何时触发</h1><p>Letterbox 的触发条件一般有：</p><ul><li><code>android:resizeableActivity=false</code> 且应用声明的宽高比与容器不兼容的时候(如屏幕宽高超出 <code>android:maxAspectRatio</code>)</li><li><code>setIgnoreOrientationRequest(true)</code> 系统设置忽略屏幕方向后，以横屏模式下打开一个强制竖屏的界面</li></ul><h1 id="3-实现方案"><a href="#3-实现方案" class="headerlink" title="3. 实现方案"></a>3. 实现方案</h1><p>Letterbox 显示的实现并不复杂，Android 12 在 <code>ActivityRecord</code> 中增加了 <code>LetterboxUiController</code> 用以控制 <code>Letterbox</code> 的布局和显示，先来看看处于 Letterbox 模式时 SurfaceFlinger 状态：</p><p><img src="http://image.hanschen.site/master/2021-10-22-10-33-26.png" alt="2021-10-22-10-33-26"></p><p>可以看到，跟正常情况相比，除了界面本身的大小和位置被缩放到指定比例外，四周还多了两个 Layer，挂在 ActiviRecord 节点下面，这两个 Layer 可根据配置进行指定的颜色填充，如果背景是壁纸的话，还可以设置壁纸的 dim 值和模糊程度，这些都可以通过 SurfaceControl 接口轻松实现。</p><p>下面简单分析一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LetterboxUiController.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLetterboxSurface</span><span class="params">(WindowState winHint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowState w = mActivityRecord.findMainWindow();</span><br><span class="line">    <span class="keyword">if</span> (w != winHint &amp;&amp; winHint != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对界面四周需要显示的 Layer 进行位置计算</span></span><br><span class="line">    layoutLetterbox(winHint);</span><br><span class="line">    <span class="keyword">if</span> (mLetterbox != <span class="keyword">null</span> &amp;&amp; mLetterbox.needsApplySurfaceChanges()) &#123;</span><br><span class="line">        <span class="comment">// 对 Surface 执行创建、参数设置等操作</span></span><br><span class="line">        mLetterbox.applySurfaceChanges(mActivityRecord.getSyncTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutLetterbox</span><span class="params">(WindowState winHint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowState w = mActivityRecord.findMainWindow();</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || winHint != <span class="keyword">null</span> &amp;&amp; w != winHint) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    updateRoundedCorners(w);</span><br><span class="line">    updateWallpaperForLetterbox(w);</span><br><span class="line">    <span class="comment">// 是否进入 Letterbox 模式的关键判断</span></span><br><span class="line">    <span class="keyword">if</span> (shouldShowLetterboxUi(w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLetterbox == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把具体逻辑委托给 Letterbox </span></span><br><span class="line">            mLetterbox = <span class="keyword">new</span> Letterbox(() -&gt; mActivityRecord.makeChildSurface(<span class="keyword">null</span>),</span><br><span class="line">                    mActivityRecord.mWmService.mTransactionFactory,</span><br><span class="line">                    mLetterboxConfiguration::isLetterboxActivityCornersRounded,</span><br><span class="line">                    <span class="keyword">this</span>::getLetterboxBackgroundColor,</span><br><span class="line">                    <span class="keyword">this</span>::hasWallpaperBackgroudForLetterbox,</span><br><span class="line">                    <span class="keyword">this</span>::getLetterboxWallpaperBlurRadius,</span><br><span class="line">                    <span class="keyword">this</span>::getLetterboxWallpaperDarkScrimAlpha);</span><br><span class="line">            mLetterbox.attachInput(w);</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityRecord.getPosition(mTmpPoint);</span><br><span class="line">        <span class="comment">// Get the bounds of the "space-to-fill". The transformed bounds have the highest</span></span><br><span class="line">        <span class="comment">// priority because the activity is launched in a rotated environment. In multi-window</span></span><br><span class="line">        <span class="comment">// mode, the task-level represents this. In fullscreen-mode, the task container does</span></span><br><span class="line">        <span class="comment">// (since the orientation letterbox is also applied to the task).</span></span><br><span class="line">        <span class="keyword">final</span> Rect transformedBounds = mActivityRecord.getFixedRotationTransformDisplayBounds();</span><br><span class="line">        <span class="keyword">final</span> Rect spaceToFill = transformedBounds != <span class="keyword">null</span></span><br><span class="line">                ? transformedBounds</span><br><span class="line">                : mActivityRecord.inMultiWindowMode()</span><br><span class="line">                        ? mActivityRecord.getRootTask().getBounds()</span><br><span class="line">                        : mActivityRecord.getRootTask().getParent().getBounds();</span><br><span class="line">        <span class="comment">// 位置计算</span></span><br><span class="line">        mLetterbox.layout(spaceToFill, w.getFrame(), mTmpPoint);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLetterbox != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLetterbox.hide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Letterbox.LetterboxSurface.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applySurfaceChanges</span><span class="params">(SurfaceControl.Transaction t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!needsApplySurfaceChanges()) &#123;</span><br><span class="line">        <span class="comment">// Nothing changed.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceFrameRelative.set(mLayoutFrameRelative);</span><br><span class="line">    <span class="keyword">if</span> (!mSurfaceFrameRelative.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSurface == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建挂在 ActivityRecord 节点下的 Surface，设置为 ColorLayer 类型</span></span><br><span class="line">            createSurface(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置颜色、位置、裁剪</span></span><br><span class="line">        mColor = mColorSupplier.get();</span><br><span class="line">        t.setColor(mSurface, getRgbColorArray());</span><br><span class="line">        t.setPosition(mSurface, mSurfaceFrameRelative.left, mSurfaceFrameRelative.top);</span><br><span class="line">        t.setWindowCrop(mSurface, mSurfaceFrameRelative.width(),</span><br><span class="line">                mSurfaceFrameRelative.height());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对壁纸背景设置透明度和模糊度</span></span><br><span class="line">        mHasWallpaperBackground = mHasWallpaperBackgroundSupplier.get();</span><br><span class="line">        updateAlphaAndBlur(t);</span><br><span class="line"></span><br><span class="line">        t.show(mSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSurface != <span class="keyword">null</span>) &#123;</span><br><span class="line">        t.hide(mSurface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="keyword">null</span> &amp;&amp; mInputInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputInterceptor.updateTouchableRegion(mSurfaceFrameRelative);</span><br><span class="line">        t.setInputWindowInfo(mSurface, mInputInterceptor.mWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>本文只是简单分析了下 Letterbox 模式的触发条件和显示的大概逻辑，还有很多细节没有涉及，比如详细的触发逻辑判断可以查看 <code>LetterboxUiController#shouldShowLetterboxUi</code> 方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;随着越来越多大屏和折叠屏设备出现，很多应用并未对不同尺寸的设备进行 UI 适配，这时候应用选择以特定的宽高比显示（&lt;strong&gt;虽然 Google 不建议这这样做，官方还是希望开发者可以对不同的屏幕尺寸进行自适应布局~&lt;/strong&gt;），当应用的宽高比和它的容器比例不兼容的时候，就会以 Letterbox 模式打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.hanschen.site/master/2021-10-21-18-17-07.png&quot; alt=&quot;2021-10-21-18-17-07&quot;&gt;&lt;/p&gt;
&lt;p&gt;Letterbox 模式下界面会以指定的比例显示，周围空白区域可以填充壁纸或者颜色。至于 Letterbox 的外观可受以下因素影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;config_letterboxActivityCornersRadius&lt;/code&gt;： 界面圆角大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config_letterboxBackgroundType&lt;/code&gt;： 背景填充类型，分别有： &lt;ul&gt;
&lt;li&gt;&lt;code&gt;LETTERBOX_BACKGROUND_APP_COLOR_BACKGROUND&lt;/code&gt;： 颜色受 &lt;code&gt;android:colorBackground&lt;/code&gt; 影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LETTERBOX_BACKGROUND_APP_COLOR_BACKGROUND_FLOATING&lt;/code&gt;： 颜色受 &lt;code&gt;android:colorBackgroundFloating&lt;/code&gt; 影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LETTERBOX_BACKGROUND_SOLID_COLOR&lt;/code&gt;： 颜色受 &lt;code&gt;config_letterboxBackgroundColor&lt;/code&gt; 影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LETTERBOX_BACKGROUND_WALLPAPER&lt;/code&gt;： 显示壁纸，此选项和 &lt;code&gt;FLAG_SHOW_WALLPAPER&lt;/code&gt; 类似，会导致壁纸窗口显示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config_letterboxBackgroundWallpaperBlurRadius&lt;/code&gt;： 壁纸模糊程度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config_letterboxBackgroundWallaperDarkScrimAlpha&lt;/code&gt;： 壁纸变暗程度&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="Android 12" scheme="http://blog.hanschen.site/tags/Android-12/"/>
    
      <category term="Android S" scheme="http://blog.hanschen.site/tags/Android-S/"/>
    
  </entry>
  
  <entry>
    <title>Android 列表滚动优化之 OverScroller 揭秘</title>
    <link href="http://blog.hanschen.site/2021/04/09/android-over-scroller/"/>
    <id>http://blog.hanschen.site/2021/04/09/android-over-scroller/</id>
    <published>2021-04-08T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><code>OverScroller</code> 在 Android 系统中承担着为 ListView、RecyclerView、ScrollView 这些滚动控件计算实时滑动位置的任务，这些位置算法直接影响着每一次滚动的体验</p><p>众所周知，Android 的动画体验<del>远</del>不如 iOS，即便如今 Android 已普遍支持 120Hz 高刷，体验起来也不是非常舒服。究其原因已经不是硬件性能限制，而是其中很多动画设计本身就有问题。苹果早在很早之前就发布了 <a href="https://developer.apple.com/videos/play/wwdc2018/803" target="_blank" rel="noopener">Designing Fluid Interfaces</a> 致力于打造一个丝滑流畅的用户体验，反观 Android，对于一个日常使用中使用最多的滑动工具类 <code>OverScroller</code> 近几年改进竟然寥寥无几，几乎没有，实在是有点想吐槽</p><p>这个系列分为两篇，第一篇主要讲述 Android 实现滚动的核心工具类 <code>OverScroller</code> 的使用方法和原理，第二篇我们将探索如何进行改进，希望我们每一次探索都能给用户体验带来提升</p><a id="more"></a><h1 id="2-使用介绍"><a href="#2-使用介绍" class="headerlink" title="2. 使用介绍"></a>2. 使用介绍</h1><p>在使用之前，先来看看 OverScroller 能做什么：</p><ul><li>startScroll：从指定位置滚动一段指定的距离然后停下，滚动效果与设置的滚动距离、滚动时间、插值器有关，<strong>跟离手速度没有关系</strong>。一般用于控制 View 滚动到<strong>指定</strong>的位置</li><li>fling：从指定位置滑动一段位置然后停下，滚动效果只与<strong>离手速度</strong>以及滑动边界有关，<strong>不能</strong>设置滚动距离、滚动时间和插值器。一般用于触摸抬手后继续让 View 滑动一会</li><li>springBack：从指定位置回弹到指定位置，一般用于实现拖拽后的回弹效果，不能指定回弹时间和插值器</li></ul><table><thead><tr><th align="center">startScroll</th><th align="center">fling</th><th align="center">springBack</th></tr></thead><tbody><tr><td align="center"><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-16-11-34.gif"></td><td align="center"><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-16-11-51.gif"></td><td align="center"><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-16-12-02.gif"></td></tr></tbody></table><p>在代码中使用也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动一个滚动</span></span><br><span class="line">mOverScroller.startScroll(<span class="number">0</span>, <span class="number">1600</span>, <span class="number">0</span>, -<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2. 启动定时刷新任务</span></span><br><span class="line">post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 计算当前最新位置信息</span></span><br><span class="line">        <span class="keyword">if</span> (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">            <span class="comment">// 4. 根据最新位置更新 View 状态</span></span><br><span class="line">            Log.d(<span class="string">"OverScroller"</span>, <span class="string">"x="</span> + mOverScroller.getCurrX() + <span class="string">", y="</span> + mOverScroller.getCurrY());</span><br><span class="line">            invalidate();</span><br><span class="line">            <span class="comment">// 5. 判断滚动是否停止，没有停止的话启动下一轮刷新任务</span></span><br><span class="line">            <span class="keyword">if</span> (!mOverScroller.isFinished()) &#123;</span><br><span class="line">                postDelayed(<span class="keyword">this</span>, <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面就是启动一个不断滚动并刷新 View 的最小逻辑（当然更工程化的实践也可以把 Runnable 的逻辑放在 View#computeScroll 里再通过 invalidate 触发）。<code>fling</code> 和 <code>springBack</code> 的启动方式也是一样的，这里就不再进行赘述了。</p><h1 id="3-深入-OverScroller-内部"><a href="#3-深入-OverScroller-内部" class="headerlink" title="3. 深入 OverScroller 内部"></a>3. 深入 OverScroller 内部</h1><p>在上面代码中可知，启动一个滚动任务后，是通过不断地调用 computeScrollOffset 来计算位置的，接下来看下代码实现</p><h2 id="3-1-startScroll"><a href="#3-1-startScroll" class="headerlink" title="3.1 startScroll"></a>3.1 startScroll</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记当前模式为 SCROLL_MODE</span></span><br><span class="line">        mMode = SCROLL_MODE;</span><br><span class="line">        <span class="comment">// mScrollerX 和 mScrollerY 均是 SplineOverScroller 实例</span></span><br><span class="line">        <span class="comment">// OverScroller 把参数分别传给 mScrollerX 和 mScrollerY，在里面做真正的计算</span></span><br><span class="line">        mScrollerX.startScroll(startX, dx, duration);</span><br><span class="line">        mScrollerY.startScroll(startY, dy, duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SplineOverScroller</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> distance, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">            mFinished = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 标记起始点和结束点</span></span><br><span class="line">            mCurrentPosition = mStart = start;</span><br><span class="line">            mFinal = start + distance;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记起始时间和动画时长</span></span><br><span class="line">            mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">            mDuration = duration;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Unused</span></span><br><span class="line">            mDeceleration = <span class="number">0.0f</span>;</span><br><span class="line">            mVelocity = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startScroll 的逻辑非常的简单，只是根据参数标记了一下开始位置、结束位置、开始时间、动画时长，还没涉及位置计算（因为位置计算是放在 computeScrollOffset 的呀）</p><p>再看看定时调用的 computeScrollOffset 逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OverScroller</span><span class="params">(Context context, Interpolator interpolator, <span class="keyword">boolean</span> flywheel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化插值器</span></span><br><span class="line">        <span class="keyword">if</span> (interpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInterpolator = <span class="keyword">new</span> Scroller.ViscousFluidInterpolator();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInterpolator = interpolator;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFinished()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_MODE:</span><br><span class="line">                <span class="keyword">long</span> time = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">                <span class="comment">// 计算已过去的时间</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> elapsedTime = time - mScrollerX.mStartTime;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> duration = mScrollerX.mDuration;</span><br><span class="line">                <span class="keyword">if</span> (elapsedTime &lt; duration) &#123;</span><br><span class="line">                    <span class="comment">// 用插值器对时间比做一个变换</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> q = mInterpolator.getInterpolation(elapsedTime / (<span class="keyword">float</span>) duration);</span><br><span class="line">                    mScrollerX.updateScroll(q);</span><br><span class="line">                    mScrollerY.updateScroll(q);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    abortAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SplineOverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateScroll</span><span class="params">(<span class="keyword">float</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据比值计算最新位置</span></span><br><span class="line">            mCurrentPosition = mStart + Math.round(q * (mFinal - mStart));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也是很简单，实在没太多可说的……就是把插值器曲线映射到位移曲线，时长如果不指定的话，默认是 250ms，插值器需要通过构造方法传入，如果不指定的话，系统默认会指定一个 <code>ViscousFluidInterpolator</code>，下面是这个插值器的曲线，可以看到是一个先缓后快再缓的动画</p><p><img src="http://image.hanschen.site/master/2021-04-09-17-31-04.png" alt="ViscousFluidInterpolator"></p><h2 id="3-2-fling-amp-springBack"><a href="#3-2-fling-amp-springBack" class="headerlink" title="3.2 fling &amp; springBack"></a>3.2 fling &amp; springBack</h2><p><code>fling</code> 和 <code>springBack</code> 为什么要一起说呢？因为 <code>fling</code> 的动画比较复杂，<code>springBack</code> 算是属于 <code>fling</code> 的其中一个子状态，考虑以下这个情况：</p><table>    <tr>        <td><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-17-44-46.gif" width="300"></td>        <td><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-18-25-11.png" width="300"></td>    </tr></table><p>我们看到当以比较大的速度执行 fling 的时候，是很容易碰到边界的，fling 会根据预设的边界值执行越界并回弹，可以把整个动画过程分解成三个阶段：</p><ul><li>SPLINE：也就是正常滑动阶段</li><li>BALLISTIC：越界减速阶段</li><li>CUBIC：回弹阶段</li></ul><p><code>springBack</code> 后执行的动画，其实就是 <code>fling</code> 的 <code>CUBIC</code> 阶段，所以干脆就放在一起说了</p><p>这个命名其实也挺有意思，这三个分别是样条曲线、弹道曲线、三次曲线，从命名上大致也可以推断出，三个阶段采用的「时间-位置」曲线是不一样的。</p><p>当然了，Android 很多控件在  fling 的时候，都把越界回弹效果取消掉，取而代之的是显示一个 <code>EdgeEffect</code>。也就是说执行完 SPLINE 阶段动画后，是看不到 <code>BALLISTIC</code> 和 <code>CUBIC</code> 的，只能看到一个边缘辉光效果，列表到达顶/底部的时候，往往一下子停在那里了~</p><h3 id="3-2-1-SPLINE"><a href="#3-2-1-SPLINE" class="headerlink" title="3.2.1 SPLINE"></a>3.2.1 SPLINE</h3><p>先来看看启动 fling 的入口函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> minX, <span class="keyword">int</span> maxX, <span class="keyword">int</span> minY, <span class="keyword">int</span> maxY, <span class="keyword">int</span> overX, <span class="keyword">int</span> overY)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记滚动模式，主要和 startScroll 进行区分</span></span><br><span class="line">        mMode = FLING_MODE;</span><br><span class="line">        mScrollerX.fling(startX, velocityX, minX, maxX, overX);</span><br><span class="line">        mScrollerY.fling(startY, velocityY, minY, maxY, overY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SplineOverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> velocity, <span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">int</span> over)</span> </span>&#123;</span><br><span class="line">            mOver = over;</span><br><span class="line">            mFinished = <span class="keyword">false</span>;</span><br><span class="line">            mCurrVelocity = mVelocity = velocity;</span><br><span class="line">            mDuration = mSplineDuration = <span class="number">0</span>;</span><br><span class="line">            mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">            mCurrentPosition = mStart = start;</span><br><span class="line"></span><br><span class="line">            mState = SPLINE;</span><br><span class="line">            <span class="keyword">double</span> totalDistance = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (velocity != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 根据速度计算滑动时长</span></span><br><span class="line">                mDuration = mSplineDuration = getSplineFlingDuration(velocity);</span><br><span class="line">                <span class="comment">// 根据速度计算滑动距离</span></span><br><span class="line">                totalDistance = getSplineFlingDistance(velocity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSplineDistance = (<span class="keyword">int</span>) (totalDistance * Math.signum(velocity));</span><br><span class="line">            mFinal = start + mSplineDistance;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFinal &lt; min) &#123;</span><br><span class="line">                <span class="comment">// 如果计算出的滑动距离超过 min 边界，则重新计算到达 min 边界时的滑动时长</span></span><br><span class="line">                adjustDuration(mStart, mFinal, min);</span><br><span class="line">                mFinal = min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFinal &gt; max) &#123;</span><br><span class="line">                <span class="comment">// 如果计算出的滑动距离超过 max 边界，则重新计算到达 max 边界时的滑动时长</span></span><br><span class="line">                adjustDuration(mStart, mFinal, max);</span><br><span class="line">                mFinal = max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getSplineDeceleration</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.log(INFLEXION * Math.abs(velocity) / (mFlingFriction * mPhysicalCoeff));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算滑动距离</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getSplineFlingDistance</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> l = getSplineDeceleration(velocity);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> decelMinusOne = DECELERATION_RATE - <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">return</span> mFlingFriction * mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算滑动时长</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSplineFlingDuration</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> l = getSplineDeceleration(velocity);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> decelMinusOne = DECELERATION_RATE - <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="number">1000.0</span> * Math.exp(l / decelMinusOne));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img style="border: none;" src="http://image.hanschen.site/master/2021-04-09-19-21-01.png"><p>看代码前先来看看上面的图，图中说明了 start、min、max、over 等位置的意义，这里简要说明一下</p><ul><li>fling 后最终停下来的位置必须在 min 和 max 区间之间</li><li>BALLISTIC 越界阶段，不能超过 over 的位置，即 over 是最大越界距离</li><li>start 可以位于 [min, max] 区间之外，如果处于区间之外，会根据速度方向和大小做一个决策，会有以下三种情况：<ul><li>速度指向边界外：先执行 BALLISTIC 越界再执行 CUBIC 回弹回到边界</li><li>速度指向边界内：如果速度足以越过边界，则按照正常流程执行，先执行 SPLINE</li><li>速度指向边界内：如果速度不足以越过边界，直接执行 CUBIC 回到边界</li></ul></li></ul><p>fling 函数主要功能：</p><ul><li>根据起始速度计算滑动的时长和距离</li><li>如果计算出最终点处于 [min, max] 区间之外，则重新计算到达边界的时长</li><li>标记当前状态为 SPLINE 状态</li></ul><p>滑动距离和时长的计算公式中，可以把 mPhysicalCoeff 也看做常数，把<strong>时长-速度公式</strong>和图像列出来：</p><p>$$<br>y=1000\cdot \exp \left( \frac{\ln \left( \frac{0.35x}{2140.47} \right)}{1.358} \right)<br>$$</p><p><img src="http://image.hanschen.site/master/2021-04-12-10-26-21.png" alt="2021-04-12-10-26-21"></p><p>再看看<strong>距离-速度公式</strong>：</p><p>$$<br>y=2140.47\cdot \exp \left( 1.74\cdot \ln \left( \frac{0.35\cdot x}{2140.47} \right) \right)<br>$$<br><img src="http://image.hanschen.site/master/2021-04-12-10-30-53.png" alt="2021-04-12-10-30-53"></p><p>可以看到距离和时长都是随着速度增大而增大的，只不过时长的增长速度在后期会有一定的收敛，保证动画时长不至于太长</p><p>还有一点要注意的是，$ \frac{Distance} {Duration} $ 的比值是一个线性函数，也就是初速度越大，平均速度越大，两者是线性增长的：</p><p>$$<br>y=\frac{2140.47\cdot \exp \left( 1.74\cdot \ln \left( \frac{0.35\cdot x}{2140.47} \right) \right)}{1000\cdot \exp \left( \frac{\ln \left( \frac{0.35x}{2140.47} \right)}{1.358} \right)}<br>$$</p><p><img src="http://image.hanschen.site/master/2021-04-12-10-45-06.png" alt="2021-04-12-10-45-06"></p><p>但是说实话，目前我暂时没想明白这两个公式的物理意义，有明白的大佬求告知~ 难道是利用了对数函数收敛的特性确定了时长公式，然后设定平均速度线性增长后，推导出距离公式？</p><p>目前只确定了滑动总距离和时长，那么中间过程是怎么更新位置的呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFinished()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> FLING_MODE:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (!mScrollerY.mFinished) &#123;</span><br><span class="line">                    <span class="comment">// 更新当前阶段的速度和位置</span></span><br><span class="line">                    <span class="keyword">if</span> (!mScrollerY.update()) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否需要进入下一动画阶段</span></span><br><span class="line">                        <span class="keyword">if</span> (!mScrollerY.continueWhenFinished()) &#123;</span><br><span class="line">                            mScrollerY.finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SplineOverScroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> time = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = time - mStartTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mDuration &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据动画时长判断当前阶段的动画是否应该结束</span></span><br><span class="line">            <span class="keyword">if</span> (currentTime &gt; mDuration) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> distance = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">                <span class="keyword">case</span> SPLINE: &#123;</span><br><span class="line">                    <span class="comment">// 把当前时间映射到 100 个采样点的曲线之中</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) currentTime / mSplineDuration;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</span><br><span class="line">                    <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</span><br><span class="line">                    <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</span><br><span class="line">                    <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 根据映射时间计算样条曲线的当前的斜率，即速度</span></span><br><span class="line">                        velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</span><br><span class="line">                        <span class="comment">// 根据映射时间计算样条曲线的高度，即距离</span></span><br><span class="line">                        distanceCoef = d_inf + (t - t_inf) * velocityCoef;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把样条距离映射回真正的距离</span></span><br><span class="line">                    distance = distanceCoef * mSplineDistance;</span><br><span class="line">                    <span class="comment">// 把样条速递易映射回真正的速度</span></span><br><span class="line">                    mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * <span class="number">1000.0f</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> BALLISTIC: &#123;</span><br><span class="line">                    <span class="comment">// 根据匀减速运动公式计算位置和速度</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t = currentTime / <span class="number">1000.0f</span>;</span><br><span class="line">                    mCurrVelocity = mVelocity + mDeceleration * t;</span><br><span class="line">                    distance = mVelocity * t + mDeceleration * t * t / <span class="number">2.0f</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> CUBIC: &#123;</span><br><span class="line">                    <span class="comment">// 根据一个自定义的三次曲线计算位置和速度</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) (currentTime) / mDuration;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t2 = t * t;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> sign = Math.signum(mVelocity);</span><br><span class="line">                    distance = sign * mOver * (<span class="number">3.0f</span> * t2 - <span class="number">2.0f</span> * t * t2);</span><br><span class="line">                    mCurrVelocity = sign * mOver * <span class="number">6.0f</span> * (- t + t2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCurrentPosition = mStart + (<span class="keyword">int</span>) Math.round(distance);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">continueWhenFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">                <span class="keyword">case</span> SPLINE:</span><br><span class="line">                    <span class="keyword">if</span> (mDuration &lt; mSplineDuration) &#123;</span><br><span class="line">                        <span class="comment">// 如果时长小于 mSplineDuration ，说明 mDuration 被重新计算过，即上面说到的到达边界的时间。那么我们需要进入越界状态</span></span><br><span class="line">                        mCurrentPosition = mStart = mFinal;</span><br><span class="line">                        mVelocity = (<span class="keyword">int</span>) mCurrVelocity;</span><br><span class="line">                        mDeceleration = getDeceleration(mVelocity);</span><br><span class="line">                        mStartTime += mDuration;</span><br><span class="line">                        onEdgeReached();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// SPLINE 停止时未到达边界，结束动画</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BALLISTIC:</span><br><span class="line">                    <span class="comment">// 越界状态结束，进入回弹阶段</span></span><br><span class="line">                    mStartTime += mDuration;</span><br><span class="line">                    startSpringback(mFinal, mStart, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CUBIC:</span><br><span class="line">                    <span class="comment">// 回弹阶段结束，结束动画</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SPLINE</code> 阶段的位置和速度完全是由预设的 <code>SPLINE_POSITION</code> 样条曲线决定的，它是一个大小为 101 的数组，里面存储了一条曲线平均采样 100 次的坐标值，初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NB_SAMPLES = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span>[] SPLINE_POSITION = <span class="keyword">new</span> <span class="keyword">float</span>[NB_SAMPLES + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span>[] SPLINE_TIME = <span class="keyword">new</span> <span class="keyword">float</span>[NB_SAMPLES + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> x_min = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> y_min = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NB_SAMPLES; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> alpha = (<span class="keyword">float</span>) i / NB_SAMPLES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> x_max = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> x, tx, coef;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            x = x_min + (x_max - x_min) / <span class="number">2.0f</span>;</span><br><span class="line">            coef = <span class="number">3.0f</span> * x * (<span class="number">1.0f</span> - x);</span><br><span class="line">            tx = coef * ((<span class="number">1.0f</span> - x) * P1 + x * P2) + x * x * x;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(tx - alpha) &lt; <span class="number">1E-5</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx &gt; alpha) x_max = x;</span><br><span class="line">            <span class="keyword">else</span> x_min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        SPLINE_POSITION[i] = coef * ((<span class="number">1.0f</span> - x) * START_TENSION + x) + x * x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码很难想象它长什么样，直接看看它的图像吧：</p><p><img src="http://image.hanschen.site/master/2021-04-12-11-24-04.png" alt="2021-04-12-11-24-04"></p><p>也就是说，SPLINE 和 startScroll 很像，位置曲线都是由一根预置的曲线决定的，把预置曲线映射真实的距离，只是 SPLINE 没有使用插值器曲线，而是使用了一根缓停的样条曲线</p><h3 id="3-2-2-BALLISTIC"><a href="#3-2-2-BALLISTIC" class="headerlink" title="3.2.2 BALLISTIC"></a>3.2.2 BALLISTIC</h3><p>SPLINE 阶段结束后，会通过 continueWhenFinished 进入下一阶段：越界阶段（前提是此时已经到达边界）。越界阶段的原理相对简单，就是一段匀减速运动（直至速度降为 0），默认加速度 a 为 -2000.0f，到达边界进入 BALLISTIC 阶段的初始化逻辑在 <code>onEdgeReached</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onEdgeReached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> velocitySquared = (<span class="keyword">float</span>) mVelocity * mVelocity;</span><br><span class="line">    <span class="comment">// 计算速度降为 0 时，运动的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = velocitySquared / (<span class="number">2.0f</span> * Math.abs(mDeceleration));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> sign = Math.signum(mVelocity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (distance &gt; mOver) &#123;</span><br><span class="line">            <span class="comment">// 如果距离大于最大距离 over，则重新计算加速度，使运动距离恰好为 over</span></span><br><span class="line">            mDeceleration = - sign * velocitySquared / (<span class="number">2.0f</span> * mOver);</span><br><span class="line">            distance = mOver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOver = (<span class="keyword">int</span>) distance;</span><br><span class="line">    <span class="comment">// 标记动画阶段</span></span><br><span class="line">    mState = BALLISTIC;</span><br><span class="line">    mFinal = mStart + (<span class="keyword">int</span>) (mVelocity &gt; <span class="number">0</span> ? distance : -distance);</span><br><span class="line">    <span class="comment">// 根据初速度和加速度计算总时长</span></span><br><span class="line">    mDuration = - (<span class="keyword">int</span>) (<span class="number">1000.0f</span> * mVelocity / mDeceleration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速度：<br>$$<br>v_t=v_0+at<br>$$</p><p>距离：<br>$$<br>s_t=v_0t + \frac{at^2} {2}<br>$$</p><p>这里有个小吐槽，加速度固定是 2000，这也太小了吧，也就是说，如果越界速度为 10000， 那么需要 5s 之后，速度才能降为 0，一个 5s 的动画童鞋们估计都知道意味着多久吧？</p><h3 id="3-2-3-CUBIC"><a href="#3-2-3-CUBIC" class="headerlink" title="3.2.3 CUBIC"></a>3.2.3 CUBIC</h3><p>上一节内容知道，BALLISTIC 阶段结束时，速度已经降低为 0，我们终于来到最后一段， 从 continueWhenFinished 里会调用 <code>startSpringback</code> 作为 CUBIC 的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSpringback</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    mFinished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 标记动画阶段</span></span><br><span class="line">    mState = CUBIC;</span><br><span class="line">    mCurrentPosition = mStart = start;</span><br><span class="line">    mFinal = end;</span><br><span class="line">    <span class="comment">// CUBIC 阶段运动总距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> delta = start - end;</span><br><span class="line">    mDeceleration = getDeceleration(delta);</span><br><span class="line">    mVelocity = -delta; <span class="comment">// only sign is used</span></span><br><span class="line">    mOver = Math.abs(delta);</span><br><span class="line">    <span class="comment">// 计算此阶段的动画时长</span></span><br><span class="line">    mDuration = (<span class="keyword">int</span>) (<span class="number">1000.0</span> * Math.sqrt(-<span class="number">2.0</span> * delta / mDeceleration));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时长计算依然使用匀加速直线运动的逻辑，想象一段初速度为 0，加速度为 a， 距离为 delta 的情况：</p><p>$$<br>delta=\frac{(v_0 + v_t)} {2} t<br>$$</p><p>则：<br>$ v_0=0，v_t=at $，那么 $ delta=\frac{at^2} {2} $，$ t=\sqrt{ \frac{2*delta} {a}}$</p><p>在 <code>update</code> 方法中，更新 CUBIC 的核心逻辑是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CUBIC: &#123;</span><br><span class="line">    <span class="comment">// 根据一个自定义的三次曲线计算位置和速度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) (currentTime) / mDuration;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> t2 = t * t;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> sign = Math.signum(mVelocity);</span><br><span class="line">    <span class="comment">// 计算运动位置</span></span><br><span class="line">    distance = sign * mOver * (<span class="number">3.0f</span> * t2 - <span class="number">2.0f</span> * t * t2);</span><br><span class="line">    <span class="comment">// 计算速度，对距离公式求导即可</span></span><br><span class="line">    mCurrVelocity = sign * mOver * <span class="number">6.0f</span> * (- t + t2);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑是这个 <code>3.0f * t2 - 2.0f * t * t2</code>, 这其实是一个比较常用的三次曲线：</p><p><img src="http://image.hanschen.site/master/2021-04-12-14-34-02.png" alt="2021-04-12-14-34-02"></p><p>在 [0, 1] 区间内，是一个缓入缓出的曲线。至此，CUBIC 的运动规律也摸清楚了，在固定时间内，把时间映射到 [0, 1] 的区间，再把 y 坐标映射实际的位置</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>目前为止，我们终于把 <code>startScroll</code> 和 <code>fling</code> 各阶段的曲线看了一遍，至于 <code>springBack</code> 和其他一些情况都大同小异，就不细述了。</p><p>很多时候 OverScroller 都是只是使用的固定的曲线映射真正的曲线，比如 <code>startScroll</code>、<code>SPLINE</code> 和 <code>CUBIC</code>，那如果想改变效果的话，是不是修改一下曲线形态就可以了呢？但一条曲线是否真的能在不同速度下都有比较好的表现吗？或许我们还要有很多的实践和尝试才能做出一段让用户舒服滑动，而这些探索和尝试，将放在下一篇文章中详细讨论~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;OverScroller&lt;/code&gt; 在 Android 系统中承担着为 ListView、RecyclerView、ScrollView 这些滚动控件计算实时滑动位置的任务，这些位置算法直接影响着每一次滚动的体验&lt;/p&gt;
&lt;p&gt;众所周知，Android 的动画体验&lt;del&gt;远&lt;/del&gt;不如 iOS，即便如今 Android 已普遍支持 120Hz 高刷，体验起来也不是非常舒服。究其原因已经不是硬件性能限制，而是其中很多动画设计本身就有问题。苹果早在很早之前就发布了 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/803&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Designing Fluid Interfaces&lt;/a&gt; 致力于打造一个丝滑流畅的用户体验，反观 Android，对于一个日常使用中使用最多的滑动工具类 &lt;code&gt;OverScroller&lt;/code&gt; 近几年改进竟然寥寥无几，几乎没有，实在是有点想吐槽&lt;/p&gt;
&lt;p&gt;这个系列分为两篇，第一篇主要讲述 Android 实现滚动的核心工具类 &lt;code&gt;OverScroller&lt;/code&gt; 的使用方法和原理，第二篇我们将探索如何进行改进，希望我们每一次探索都能给用户体验带来提升&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="OverScroller" scheme="http://blog.hanschen.site/tags/OverScroller/"/>
    
  </entry>
  
  <entry>
    <title>使用 Ninja 提升模块编译速度</title>
    <link href="http://blog.hanschen.site/2019/11/20/ninja_compile/"/>
    <id>http://blog.hanschen.site/2019/11/20/ninja_compile/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>从 Android 7 开始，Android 源码编译时默认使用 Ninja，编译时，会先把 makefile 和 bp 转换成 ninja 再进行编译。这个转换过程非常慢（需要遍历处理所有关联的 makefile、bp 文件），即使只是通过 <code>mm</code> 或 <code>mmm</code> 编译某个模块，也会有很多因素触发 ninja 文件的重新生成，而这对基于源码开发的模块很不友好，编译好慢！</p><a id="more"></a><h1 id="2-初识-ninja"><a href="#2-初识-ninja" class="headerlink" title="2. 初识 ninja"></a>2. 初识 ninja</h1><p>AOSP 在源码中已经内置了一个 ninja 执行文件，路径为：<code>./prebuilts/build-tools/linux-x86/bin/ninja</code></p><p>我们先看看它的 help：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ./prebuilts/build-tools/linux-x86/bin/ninja -h</span><br><span class="line">usage: ninja [options] [targets...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> targets are unspecified, builds the <span class="string">'default'</span> target (see manual).</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  --version      <span class="built_in">print</span> ninja version (<span class="string">"1.9.0"</span>)</span><br><span class="line">  -v, --verbose  show all <span class="built_in">command</span> lines <span class="keyword">while</span> building</span><br><span class="line"></span><br><span class="line">  -C DIR   change to DIR before doing anything <span class="keyword">else</span></span><br><span class="line">  -f FILE  specify input build file [default=build.ninja]</span><br><span class="line"></span><br><span class="line">  -j N     run N <span class="built_in">jobs</span> <span class="keyword">in</span> parallel (0 means infinity) [default=10 on this system]</span><br><span class="line">  -k N     keep going until N <span class="built_in">jobs</span> fail (0 means infinity) [default=1]</span><br><span class="line">  -l N     <span class="keyword">do</span> not start new <span class="built_in">jobs</span> <span class="keyword">if</span> the load average is greater than N</span><br><span class="line">  -n       dry run (don<span class="string">'t run commands but act like they succeeded)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  -d MODE  enable debugging (use '</span>-d list<span class="string">' to list modes)</span></span><br><span class="line"><span class="string">  -t TOOL  run a subtool (use '</span>-t list<span class="string">' to list subtools)</span></span><br><span class="line"><span class="string">    terminates toplevel options; further flags are passed to the tool</span></span><br><span class="line"><span class="string">  -w FLAG  adjust warnings (use '</span>-w list<span class="string">' to list warnings)</span></span><br></pre></td></tr></table></figure><p>简单使用的话，我们关注它的两个参数就行了</p><ul><li><code>-f</code>：这个参数指定的就是输入文件，也就是 makefile 和 bp 转换后的 ninja 文件，一般位于 <code>./out</code> 目录，后面会说</li><li><code>targets</code>：目标，这个和 makefile 是类似的，就是我们最终需要的产物，例如：Launcher3QuickStep、SystemUI。那么这些 targets 名是哪里定义的呢？要知道对应模块的对应的 target 名，只需要：<ul><li>若模块使用的是 Android.mk：查找 <code>LOCAL_PACKAGE_NAME</code> 或 <code>LOCAL_MODULE</code> 等对应的值</li><li>若模块使用的是 Android.bp：查找 module 中 name 对应的值</li></ul></li></ul><p>举个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ android-10.0.0_r11 ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_walleye.ninja Launcher3QuickStep</span><br><span class="line">[3/13] Target Java: out/target/common/obj/JAVA_LIBRARIES/Launcher3QuickStepLib_intermediates/classes-full-debug.jar</span><br><span class="line">注: 某些输入文件使用或覆盖了已过时的 API。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。</span><br><span class="line">注: 某些输入文件使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br><span class="line">[13/13] Install: out/target/product/walleye/system/product/priv-app/Launcher3QuickStep/Launcher3QuickStep.apk</span><br></pre></td></tr></table></figure><p>就这样，不需要通过 <code>mm</code> 或者 <code>mmm</code> 命令，目标产物同样生成了。我们看看耗时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ android-10.0.0_r11 time ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_walleye.ninja Launcher3QuickStep</span><br><span class="line">[3/13] Target Java: out/target/common/obj/JAVA_LIBRARIES/Launcher3QuickStepLib_intermediates/classes-full-debug.jar</span><br><span class="line">注: 某些输入文件使用或覆盖了已过时的 API。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。</span><br><span class="line">注: 某些输入文件使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br><span class="line">[13/13] Install: out/target/product/walleye/system/product/priv-app/Launcher3QuickStep/Launcher3QuickStep.apk</span><br><span class="line"></span><br><span class="line">real0m18.994s</span><br><span class="line">user1m20.548s</span><br><span class="line">sys0m2.872s</span><br></pre></td></tr></table></figure><p>可以看到，整个编译在 18s 完成了，相比动辄七八分钟的 <code>mmm</code>，效率提升还是很可观的。</p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><p>虽然 ninja 很方便，但要用它来编译单个模块，还是有一些限制和注意事项的：</p><ul><li>使用前需把对应模块编译一遍，用于生产 ninja 文件（全编或 <code>mmm</code> 都可以）</li><li>全编后，生成的 ninja 文件为：<code>./out/combined-[TARGET-PRODUCT].ninja</code></li><li><code>mmm</code> 编译后，生成的 ninja 文件为：<code>./out/combined-[TARGET-PRODUCT]-_[path_to_your_module_makefile].ninja</code>，比如：<code>./out/combined-aosp_walleye-_packages_apps_Launcher3_Android.mk.ninja</code></li><li>如果修改了 Android.mk 或 Android.bp，需使用传统的 make 命令进行编译以重新生成包含新依赖规则的 ninja 文件</li><li>可以把 ninja 放到 PATH 环境变量中，这样就不用每次都敲 ./prebuilts/build-tools/linux-x86/bin/ninja 这个路径了</li></ul><h2 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h2><p>为 Launcher 和 SystemUI 准备一份开箱即用的指令，尽情玩耍吧~</p><p>Launcher：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-qssi-_packages_apps_Launcher3_Android.mk.ninja Launcher3QuickStep</span><br></pre></td></tr></table></figure><p>SystemUI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-qssi-_frameworks_base_packages_SystemUI_Android.mk.ninja SystemUI</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;从 Android 7 开始，Android 源码编译时默认使用 Ninja，编译时，会先把 makefile 和 bp 转换成 ninja 再进行编译。这个转换过程非常慢（需要遍历处理所有关联的 makefile、bp 文件），即使只是通过 &lt;code&gt;mm&lt;/code&gt; 或 &lt;code&gt;mmm&lt;/code&gt; 编译某个模块，也会有很多因素触发 ninja 文件的重新生成，而这对基于源码开发的模块很不友好，编译好慢！&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 黑暗模式（Dark Mode）源码解析</title>
    <link href="http://blog.hanschen.site/2019/10/22/android_q_dark_mode/"/>
    <id>http://blog.hanschen.site/2019/10/22/android_q_dark_mode/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>随着 Android Q 发布，「黑暗模式」或者说是「夜间模式」终于在此版本中得到了支持，官方介绍见：<a href="https://developer.android.com/guide/topics/ui/look-and-feel/darktheme" target="_blank" rel="noopener">https://developer.android.com/guide/topics/ui/look-and-feel/darktheme</a>，再看看效果图：</p><p><img src="http://image.hanschen.site/master/2019-10-21-17-21-50.png" alt="2019-10-21-17-21-50.png"></p><p>其实这个功能魅族在两年前就已支持，不得不说 Android 有点落后了，今天我们就来看看原生是怎么实现全局夜间模的吧</p><a id="more"></a><h1 id="2-打开与关闭"><a href="#2-打开与关闭" class="headerlink" title="2. 打开与关闭"></a>2. 打开与关闭</h1><p>从文档上我们可以可知，打开夜间模式有三个方法：</p><ul><li>设置 -&gt; 显示 -&gt; 深色主题背景</li><li>下拉通知栏中开启</li><li>Pixel 手机开启省点模式时会自动激活夜间模式</li></ul><h1 id="3-如何适配"><a href="#3-如何适配" class="headerlink" title="3. 如何适配"></a>3. 如何适配</h1><p>打开后，我们会发现，除原生几个应用生效外，其他应用依然没有变成深色主题，那么应用该如何适配呢？官方提供了下面两种方法：</p><h2 id="3-1-让应用主题继承-DayNight-主题"><a href="#3-1-让应用主题继承-DayNight-主题" class="headerlink" title="3.1. 让应用主题继承 DayNight 主题"></a>3.1. 让应用主题继承 <code>DayNight</code> 主题</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.DayNight"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者继承自</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承后，如果当前开启了夜间模式，系统会自动从 night-qualified 中加载资源，所以应用的颜色、图标等资源应尽量避免硬编码，而是推荐使用新增 attributes 指向不同的资源，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?android:attr/textColorPrimary</span><br><span class="line">?attr/colorControlNormal</span><br></pre></td></tr></table></figure><p>另外，如果应用希望主动切换夜间/日间模式，可以通过 <code>AppCompatDelegate.setDefaultNightMode()</code> 接口主动切换</p><h2 id="3-2-通过-forceDarkAllowed-启用"><a href="#3-2-通过-forceDarkAllowed-启用" class="headerlink" title="3.2. 通过 forceDarkAllowed 启用"></a>3.2. 通过 forceDarkAllowed 启用</h2><p>如果应用不想自己去适配各种颜色，图标等，可以通过在主题中添加 <code>android:forceDarkAllowed=&quot;true&quot;</code> 标记，这样系统在夜间模式时，会强制改变应用颜色，自动进行适配（这个功能也是本文主要探讨的）。不过如果你的应用本身使用的就是 <code>DayNight</code> 或 <code>Dark Theme</code>，forceDarkAllowed 是不会生效的。</p><p>另外，如果你不希望某个 view 被强制夜间模式处理，则可以给 view 添加 <code>android:forceDarkAllowed=&quot;false&quot;</code> 或者 <a href="https://developer.android.com/reference/android/view/View.html#setForceDarkAllowed(boolean)" target="_blank" rel="noopener">view.setForceDarkAllowed(false)</a>，设置之后，即使打开了夜间模式且主题添加了 forceDarkAllowed，该 view 也不会变深色。比较重要的一点是，这个接口只能关闭夜间模式，不能开启夜间模式，也就是说，如果主题中<strong>没有</strong>显示声明 forceDarkAllowed，<code>view.setForceDarkAllowed(true)</code> 是没办法让 view 单独变深色的。如果 view 关闭了夜间模式，那么它的子 view 也会强制关闭夜间模式</p><p>总结如下：</p><ul><li>主题若添加 forceDarkAllowed=false，无论 view 是否开启 forceDarkAllowed 都不会打开夜间模式</li><li>主题若添加 forceDarkAllowed=true，view 可以通过 forceDarkAllowed 关闭夜间模式，一旦关闭，子 view 的夜间模式也会被关闭</li><li>如果父 view 或主题设置了 forceDarkAllowed=false，子 view 无法通过 forceDarkAllowed=true 单独打开夜间模式为</li><li>若使用的是 <code>DayNight</code> 或 <code>Dark Theme</code> 主题，则所有 forceDarkAllowed 都不生效</li></ul><h1 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4. 实现原理"></a>4. 实现原理</h1><p>通过继承主题适配夜间模式的原理本质是根据 ui mode 加载 night-qualified 下是资源，这个并非 Android Q 新增的东西，我们这里不再描述。现在主要来看看 forceDarkAllowed 是如何让系统变深色的。</p><p>既然一切的源头都是 <code>android:forceDarkAllowed</code> 这个属性，那我们就从它入手吧，首先我们要知道，上面我们说的 <code>android:forceDarkAllowed</code> 其实是分为两个用处，它们分别的定义如下：</p><p>frameworks/base/core/res/res/values/attrs.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"View"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;p&gt;Whether or not the force dark feature is allowed to be applied to this View.</span></span><br><span class="line"><span class="comment">            &lt;p&gt;Setting this to false will disable the auto-dark feature on this View draws</span></span><br><span class="line"><span class="comment">            including any descendants.</span></span><br><span class="line"><span class="comment">            &lt;p&gt;Setting this to true will allow this view to be automatically made dark, however</span></span><br><span class="line"><span class="comment">            a value of 'true' will not override any 'false' value in its parent chain nor will</span></span><br><span class="line"><span class="comment">            it prevent any 'false' in any of its children. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"forceDarkAllowed"</span> <span class="attr">format</span>=<span class="string">"boolean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"Theme"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;p&gt;Whether or not the force dark feature is allowed to be applied to this theme.</span></span><br><span class="line"><span class="comment">             &lt;p&gt;Setting this to false will disable the auto-dark feature on everything this</span></span><br><span class="line"><span class="comment">             theme is applied to along with anything drawn by any children of views using</span></span><br><span class="line"><span class="comment">             this theme.</span></span><br><span class="line"><span class="comment">             &lt;p&gt;Setting this to true will allow this view to be automatically made dark, however</span></span><br><span class="line"><span class="comment">             a value of 'true' will not override any 'false' value in its parent chain nor will</span></span><br><span class="line"><span class="comment">             it prevent any 'false' in any of its children. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"forceDarkAllowed"</span> <span class="attr">format</span>=<span class="string">"boolean"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个是 View 级别的，一个是 Theme 级别的。</p><h2 id="4-1-Theme-级别-forceDarkAllowed"><a href="#4-1-Theme-级别-forceDarkAllowed" class="headerlink" title="4.1. Theme 级别 forceDarkAllowed"></a>4.1. Theme 级别 forceDarkAllowed</h2><p>从上面的总结来看，Theme 级别的开关优先级是最高的，控制粒度也最大，我们看看源码里面使用它的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateForceDarkMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 渲染线程为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统是否打开了黑暗模式</span></span><br><span class="line">    <span class="keyword">boolean</span> useAutoDark = getNightMode() == Configuration.UI_MODE_NIGHT_YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useAutoDark) &#123;</span><br><span class="line">        <span class="comment">// forceDarkAllowed 默认值，开发者模式是否打开了强制 smart dark 选项</span></span><br><span class="line">        <span class="keyword">boolean</span> forceDarkAllowedDefault =</span><br><span class="line">                SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, <span class="keyword">false</span>);</span><br><span class="line">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme);</span><br><span class="line">        <span class="comment">// useAutoDark = 使用浅色主题 &amp;&amp; 主题中声明的 forceDarkAllowed 值</span></span><br><span class="line">        useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, <span class="keyword">true</span>)</span><br><span class="line">                &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码，设置是否强制夜间模式</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer.setForceDark(useAutoDark)) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't require regenerating all display lists to apply this setting</span></span><br><span class="line">        invalidateWorld(mView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/graphics/java/android/graphics/HardwareRenderer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setForceDark</span><span class="params">(<span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mForceDark != enable) &#123;</span><br><span class="line">        mForceDark = enable;</span><br><span class="line">        <span class="comment">// native 代码，mNativeProxy 其实是  RenderThread 代理类的指针</span></span><br><span class="line">        nSetForceDark(mNativeProxy, enable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码还是比较简单，判断系统：</p><ul><li>是否打开了夜间模式</li><li>是否使用浅色主题</li><li>Theme_forceDarkAllowed 是否为 true</li></ul><p>三者同时为 true 时才会设置夜间模式，而 updateForceDarkMode 调用的时机分别是在 <code>ViewRootImpl#setView</code> 和 <code>ViewRootImpl#updateConfiguration</code>，也就是初始化和夜间模式切换的时候都会调用，确保夜间模式能及时启用和关闭。继续跟踪 <code>HardwareRenderer#setForceDark</code> 发现，这是一个 native 方法，所以接下来让我们进入 native 世界，nSetForceDark 对应的实现位于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_ThreadedRenderer_setForceDark</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jboolean enable)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    proxy-&gt;setForceDark(enable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></span><br><span class="line"><span class="keyword">void</span> RenderProxy::setForceDark(<span class="keyword">bool</span> enable) &#123;</span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>().post([<span class="keyword">this</span>, enable]() &#123; mContext-&gt;setForceDark(enable); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/renderthread/CanvasContext.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasContext</span> :</span> <span class="keyword">public</span> IFrameCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setForceDark</span><span class="params">(<span class="keyword">bool</span> enable)</span> </span>&#123; mUseForceDark = enable; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">useForceDark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUseForceDark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 默认关闭强制夜间模式</span></span><br><span class="line">    <span class="keyword">bool</span> mUseForceDark = <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终就是设置了一个 CanvasContext 的变量值而已，什么都还没有做，那么这个变量值的作用是什么，什么时候生效呢？我们进一步查看使用的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/TreeInfo.cpp</span></span><br><span class="line">TreeInfo::TreeInfo(TraversalMode mode, renderthread::CanvasContext&amp; canvasContext)</span><br><span class="line">        : mode(mode)</span><br><span class="line">        , prepareTextures(mode == MODE_FULL)</span><br><span class="line">        , canvasContext(canvasContext)</span><br><span class="line">        , damageGenerationId(canvasContext.getFrameNumber())</span><br><span class="line">        <span class="comment">// 初始化 TreeInfo 的 disableForceDark 变量，注意变量值意义的变化，0 代表打开夜间模式，&gt;0 代表关闭夜间模式</span></span><br><span class="line">        , disableForceDark(canvasContext.useForceDark() ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        , screenSize(canvasContext.getNextFrameSize()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步看看 disableForceDark 使用的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RenderNode.cpp</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个可以说是核心方法了，handleForceDark 方法调用栈如下：</span></span><br><span class="line"><span class="comment"> * - RenderNode#prepareTreeImpl</span></span><br><span class="line"><span class="comment"> * - RenderNode#pushStagingDisplayListChanges</span></span><br><span class="line"><span class="comment"> * - RenderNode#syncDisplayList</span></span><br><span class="line"><span class="comment"> * - RenderNode#handleForceDark</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 而 RenderNode#prepareTree 是绘制的必经之路，每一个节点都会走一遍这个流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> RenderNode::handleForceDark(android::uirenderer::TreeInfo *info) &#123;</span><br><span class="line">    <span class="comment">// 若没打开强制夜间模式，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(!info || info-&gt;disableForceDark)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有文字、是否有子节点、子节点数量等情况，得出当前 Node 属于 Foreground 还是 Background</span></span><br><span class="line">    <span class="keyword">auto</span> usage = usageHint();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; children = mDisplayList-&gt;mChildNodes;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayList-&gt;hasText()) &#123;</span><br><span class="line">        usage = UsageHint::Foreground;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usage == UsageHint::Unknown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (children.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            usage = UsageHint::Background;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children.size() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                children.front().getRenderNode()-&gt;usageHint() !=</span><br><span class="line">                        UsageHint::Background) &#123;</span><br><span class="line">            usage = UsageHint::Background;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (children.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Crude overlap check</span></span><br><span class="line">        SkRect drawn = SkRect::MakeEmpty();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = children.rbegin(); iter != children.rend(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; child = iter-&gt;getRenderNode();</span><br><span class="line">            <span class="comment">// We use stagingProperties here because we haven't yet sync'd the children</span></span><br><span class="line">            SkRect bounds = SkRect::MakeXYWH(child-&gt;stagingProperties().getX(), child-&gt;stagingProperties().getY(),</span><br><span class="line">                    child-&gt;stagingProperties().getWidth(), child-&gt;stagingProperties().getHeight());</span><br><span class="line">            <span class="keyword">if</span> (bounds.contains(drawn)) &#123;</span><br><span class="line">                <span class="comment">// This contains everything drawn after it, so make it a background</span></span><br><span class="line">                child-&gt;setUsageHint(UsageHint::Background);</span><br><span class="line">            &#125;</span><br><span class="line">            drawn.join(bounds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 UsageHint 设置变色策略：Dark（压暗）、Light（提亮）</span></span><br><span class="line">    mDisplayList-&gt;mDisplayList.applyColorTransform(</span><br><span class="line">            usage == UsageHint::Background ? ColorTransform::Dark : ColorTransform::Light);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/libs/hwui/RecordingCanvas.cpp</span></span><br><span class="line"><span class="keyword">void</span> DisplayListData::applyColorTransform(ColorTransform transform) &#123;</span><br><span class="line">    <span class="comment">// transform: Dark 或 Light</span></span><br><span class="line">    <span class="comment">// color_transform_fns 是一个对应所有绘制指令的函数指针数组，主要是对 op 的 paint 变色或对 bitmap 添加 colorfilter</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">map</span>(color_transform_fns, transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> DisplayListData::<span class="built_in">map</span>(<span class="keyword">const</span> Fn fns[], Args... args) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> end = fBytes.get() + fUsed;</span><br><span class="line">    <span class="comment">// 遍历当前的绘制的 op</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* ptr = fBytes.get(); ptr &lt; end;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> op = (<span class="keyword">const</span> Op*)ptr;</span><br><span class="line">        <span class="keyword">auto</span> type = op-&gt;type;</span><br><span class="line">        <span class="keyword">auto</span> skip = op-&gt;skip;</span><br><span class="line">        <span class="comment">// 根据 type 找到对应的 fn，根据调用关系，我们知道 fns 数组对应 color_transform_fns，这个数组其实是一个函数指针数组，下面看看定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> fn = fns[type]) &#123;  <span class="comment">// We replace no-op functions with nullptrs</span></span><br><span class="line">            <span class="comment">// 执行 </span></span><br><span class="line">            fn(op, args...);        <span class="comment">// to avoid the overhead of a pointless call.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += skip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(T) colorTransformForOp<span class="meta-string">&lt;T&gt;(),</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> color_transform_fn color_transform_fns[] = &#123;</span><br><span class="line">        X(Flush)</span><br><span class="line">        X(Save)</span><br><span class="line">        X(Restore)</span><br><span class="line">        X(SaveLayer)</span><br><span class="line">        X(SaveBehind)</span><br><span class="line">        X(Concat)</span><br><span class="line">        X(SetMatrix)</span><br><span class="line">        X(Translate)</span><br><span class="line">        X(ClipPath)</span><br><span class="line">        X(ClipRect)</span><br><span class="line">        X(ClipRRect)</span><br><span class="line">        X(ClipRegion)</span><br><span class="line">        X(DrawPaint)</span><br><span class="line">        X(DrawBehind)</span><br><span class="line">        X(DrawPath)</span><br><span class="line">        X(DrawRect)</span><br><span class="line">        X(DrawRegion)</span><br><span class="line">        X(DrawOval)</span><br><span class="line">        X(DrawArc)</span><br><span class="line">        X(DrawRRect)</span><br><span class="line">        X(DrawDRRect)</span><br><span class="line">        X(DrawAnnotation)</span><br><span class="line">        X(DrawDrawable)</span><br><span class="line">        X(DrawPicture)</span><br><span class="line">        X(DrawImage)</span><br><span class="line">        X(DrawImageNine)</span><br><span class="line">        X(DrawImageRect)</span><br><span class="line">        X(DrawImageLattice)</span><br><span class="line">        X(DrawTextBlob)</span><br><span class="line">        X(DrawPatch)</span><br><span class="line">        X(DrawPoints)</span><br><span class="line">        X(DrawVertices)</span><br><span class="line">        X(DrawAtlas)</span><br><span class="line">        X(DrawShadowRec)</span><br><span class="line">        X(DrawVectorDrawable)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br></pre></td></tr></table></figure><p>color_transform_fn 宏定义展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">color_transform_fn</span> <span class="title">colorTransformForOp</span>() &#123;</span></span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">        <span class="comment">// op 变量中是否同时包含 paint 及 palette 属性，若同时包含，则是绘制 Image 或者 VectorDrawable 的指令</span></span><br><span class="line">        <span class="comment">// 参考：frameworks/base/libs/hwui/RecordingCanvas.cpp 中各 Op 的定义</span></span><br><span class="line">        <span class="keyword">constexpr</span>(has_paint&lt;T&gt; &amp;&amp; has_palette&lt;T&gt;) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> [](<span class="keyword">const</span> <span class="keyword">void</span>* opRaw, ColorTransform transform) &#123;</span><br><span class="line">                <span class="keyword">const</span> T* op = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(opRaw);</span><br><span class="line">                <span class="comment">// 关键变色方法，根据 palette 叠加 colorfilter</span></span><br><span class="line">                transformPaint(transform, <span class="keyword">const_cast</span>&lt;SkPaint*&gt;(&amp;(op-&gt;paint)), op-&gt;palette);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">        <span class="comment">// op 变量中是否包含 paint 属性，普通绘制指令</span></span><br><span class="line">        <span class="keyword">constexpr</span>(has_paint&lt;T&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> [](<span class="keyword">const</span> <span class="keyword">void</span>* opRaw, ColorTransform transform) &#123;</span><br><span class="line">                <span class="keyword">const</span> T* op = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(opRaw);</span><br><span class="line">                <span class="comment">// 关键变色方法，对 paint 颜色进行变换</span></span><br><span class="line">                transformPaint(transform, <span class="keyword">const_cast</span>&lt;SkPaint*&gt;(&amp;(op-&gt;paint)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// op 变量不包含 paint 属性，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> color_transform_fn color_transform_fns[] = &#123;</span><br><span class="line">        <span class="comment">// 根据 Flush、Save、DrawImage等不同绘制 op，返回不同的函数指针</span></span><br><span class="line">        colorTransformForOp&lt;Flush&gt;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们再一次看看 map 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> DisplayListData::<span class="built_in">map</span>(<span class="keyword">const</span> Fn fns[], Args... args) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> end = fBytes.get() + fUsed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* ptr = fBytes.get(); ptr &lt; end;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> op = (<span class="keyword">const</span> Op*)ptr;</span><br><span class="line">        <span class="keyword">auto</span> type = op-&gt;type;</span><br><span class="line">        <span class="keyword">auto</span> skip = op-&gt;skip;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> fn = fns[type]) &#123;  <span class="comment">// We replace no-op functions with nullptrs</span></span><br><span class="line">            <span class="comment">// 对 op 的 paint 进行颜色变换或叠加 colorfilter</span></span><br><span class="line">            fn(op, args...);        <span class="comment">// to avoid the overhead of a pointless call.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += skip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴了一大段代码，虽然代码中已经包含了注释，但还是可能比较晕，我们先来整理下：</p><ul><li>CanvasContext.mUseForceDark 只会影响 TreeInfo.disableForceDark 的初始化</li><li>TreeInfo.disableForceDark 若大于 0，RenderNode 在执行 handleForceDark 就会直接退出</li><li>handleForceDark 方法里会根据 UsageHint 类型，对所有 op 中的 paint 颜色进行变换，如果是绘制图片，则叠加一个反转的 colorfilter。变换策略有：Dark、Light</li></ul><p>接下来让我们来看 paint 和 colorfilter 的变色实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">transformPaint</span><span class="params">(ColorTransform transform, SkPaint* paint)</span> </span>&#123;</span><br><span class="line">    applyColorTransform(transform, *paint);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyColorTransform</span><span class="params">(ColorTransform transform, SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transform == ColorTransform::None) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对画笔颜色进行颜色变换</span></span><br><span class="line">    SkColor newColor = transformColor(transform, paint.getColor());</span><br><span class="line">    paint.setColor(newColor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paint.getShader()) &#123;</span><br><span class="line">        SkShader::GradientInfo info;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">array</span>&lt;SkColor, 10&gt; _colorStorage;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">array</span>&lt;SkScalar, _colorStorage.size()&gt; _offsetStorage;</span><br><span class="line">        info.fColorCount = _colorStorage.size();</span><br><span class="line">        info.fColors = _colorStorage.data();</span><br><span class="line">        info.fColorOffsets = _offsetStorage.data();</span><br><span class="line">        SkShader::GradientType type = paint.getShader()-&gt;asAGradient(&amp;info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info.fColorCount &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> SkShader::kLinear_GradientType:</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.fColorCount; i++) &#123;</span><br><span class="line">                        <span class="comment">// 对 shader 中的颜色进行颜色变换</span></span><br><span class="line">                        info.fColors[i] = transformColor(transform, info.fColors[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    paint.setShader(SkGradientShader::MakeLinear(info.fPoint, info.fColors,</span><br><span class="line">                                                                 info.fColorOffsets, info.fColorCount,</span><br><span class="line">                                                                 info.fTileMode, info.fGradientFlags, <span class="literal">nullptr</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paint.getColorFilter()) &#123;</span><br><span class="line">        SkBlendMode mode;</span><br><span class="line">        SkColor color;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> LRU this or something to avoid spamming new color mode filters</span></span><br><span class="line">        <span class="keyword">if</span> (paint.getColorFilter()-&gt;asColorMode(&amp;color, &amp;mode)) &#123;</span><br><span class="line">            <span class="comment">// 对 colorfilter 中的颜色进行颜色变换</span></span><br><span class="line">            color = transformColor(transform, color);</span><br><span class="line">            paint.setColorFilter(SkColorFilter::MakeModeFilter(color, mode));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，就是对颜色进行变换，进一步看看变色逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提亮颜色</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SkColor <span class="title">makeLight</span><span class="params">(SkColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转换成 Lab 模式</span></span><br><span class="line">    Lab lab = sRGBToLab(color);</span><br><span class="line">    <span class="comment">// 对明度进行反转，明度越高，反转后越低</span></span><br><span class="line">    <span class="keyword">float</span> invertedL = <span class="built_in">std</span>::min(<span class="number">110</span> - lab.L, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> (invertedL &gt; lab.L) &#123;</span><br><span class="line">        <span class="comment">// 反转后的明度高于原明度，则使用反转后的明度</span></span><br><span class="line">        lab.L = invertedL;</span><br><span class="line">        <span class="keyword">return</span> LabToSRGB(lab, SkColorGetA(color));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压暗颜色</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SkColor <span class="title">makeDark</span><span class="params">(SkColor color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转换成 Lab 模式</span></span><br><span class="line">    Lab lab = sRGBToLab(color);</span><br><span class="line">    <span class="comment">// 对明度进行反转，明度越高，反转后越低</span></span><br><span class="line">    <span class="keyword">float</span> invertedL = <span class="built_in">std</span>::min(<span class="number">110</span> - lab.L, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> (invertedL &lt; lab.L) &#123;</span><br><span class="line">        <span class="comment">// 反转后的明度低于原明度，则使用反转后的明度</span></span><br><span class="line">        lab.L = invertedL;</span><br><span class="line">        <span class="comment">// 使用 rgb 格式返回</span></span><br><span class="line">        <span class="keyword">return</span> LabToSRGB(lab, SkColorGetA(color));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接返回原颜色</span></span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> SkColor <span class="title">transformColor</span><span class="params">(ColorTransform transform, SkColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (transform) &#123;</span><br><span class="line">        <span class="keyword">case</span> ColorTransform::Light:</span><br><span class="line">            <span class="keyword">return</span> makeLight(color);</span><br><span class="line">        <span class="keyword">case</span> ColorTransform::Dark:</span><br><span class="line">            <span class="keyword">return</span> makeDark(color);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，对 paint 的变换结束，看来无非就是反转明度。</p><p>再来看看对图片的变换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">transformPaint</span><span class="params">(ColorTransform transform, SkPaint* paint, BitmapPalette palette)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 palette 和 colorfilter 判断图片是亮还是暗的</span></span><br><span class="line">    palette = filterPalette(paint, palette);</span><br><span class="line">    <span class="keyword">bool</span> shouldInvert = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (palette == BitmapPalette::Light &amp;&amp; transform == ColorTransform::Dark) &#123;</span><br><span class="line">        <span class="comment">// 图片本身是亮的，但是要求变暗，反转</span></span><br><span class="line">        shouldInvert = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (palette == BitmapPalette::Dark &amp;&amp; transform == ColorTransform::Light) &#123;</span><br><span class="line">        <span class="comment">// 图片本身是暗的，但是要求变亮，反转</span></span><br><span class="line">        shouldInvert = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldInvert) &#123;</span><br><span class="line">        SkHighContrastConfig config;</span><br><span class="line">        config.fInvertStyle = SkHighContrastConfig::InvertStyle::kInvertLightness;</span><br><span class="line">        <span class="comment">// 叠加一个亮度反转的 colorfilter</span></span><br><span class="line">        paint-&gt;setColorFilter(SkHighContrastFilter::Make(config)-&gt;makeComposed(paint-&gt;refColorFilter()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldInvert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，bitmap 的变换也分析完了，呼~</p><h2 id="4-2-View-级别-forceDarkAllowed"><a href="#4-2-View-级别-forceDarkAllowed" class="headerlink" title="4.2. View 级别 forceDarkAllowed"></a>4.2. View 级别 forceDarkAllowed</h2><p>但是，还没完呢<del>~</del>还记得我们最开始说的，除了 Theme 级别，还有一个 View 级别的 forceDarkAllowed，通过 View 级别 forceDarkAllowed 可以关掉它及它的子 view 的夜间模式开关。依然从 java 层看下去哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rameworks/base/core/java/android/view/View.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line">            <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.View_forceDarkAllowed:</span><br><span class="line">                    <span class="comment">// 注意，这个默认是 true 的</span></span><br><span class="line">                    mRenderNode.setForceDarkAllowed(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/graphics/java/android/graphics/RenderNode.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setForceDarkAllowed</span><span class="params">(<span class="keyword">boolean</span> allow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 又是 native 方法</span></span><br><span class="line">        <span class="keyword">return</span> nSetAllowForceDark(mNativeRenderNode, allow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_RenderNode.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_view_RenderNode_setAllowForceDark</span><span class="params">(jlong renderNodePtr, jboolean allow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SET_AND_DIRTY(setAllowForceDark, allow, RenderNode::GENERIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/libs/hwui/RenderProperties.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ANDROID_API</span> <span class="title">RenderProperties</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">setAllowForceDark</span><span class="params">(<span class="keyword">bool</span> allow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置到 mPrimitiveFields.mAllowForceDark 变量中</span></span><br><span class="line">        <span class="keyword">return</span> RP_SET(mPrimitiveFields.mAllowForceDark, allow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getAllowForceDark</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPrimitiveFields.mAllowForceDark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Theme 级别的一样，仅仅只是设置到变量中而已，关键是要看哪里使用这个变量，经过查找，我们发现，它的使用同样在 RenderNode 的 prepareTreeImpl 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="keyword">bool</span> functorsNeedLayer) &#123;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">// 1. 如果 view 关闭了夜间模式，会在这里让 info.disableForceDark 加 1</span></span><br><span class="line">    <span class="comment">// 2. info.disableForceDark 正是 handleForceDark 中关键变量，还记得吗？</span></span><br><span class="line">    <span class="comment">// 3. nfo.disableForceDark 大于 0 会让此 RenderNode 跳过夜间模式处理</span></span><br><span class="line">    <span class="comment">// 4. 如果 info.disableForceDark 本身已经大于 0 了，view.setForceDarkAllowed(true) 也毫无意义</span></span><br><span class="line">    <span class="keyword">if</span> (!mProperties.getAllowForceDark()) &#123;</span><br><span class="line">        info.disableForceDark++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareLayer(info, animatorDirtyMask);</span><br><span class="line">    <span class="keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        <span class="comment">// 这里面会调用 handleForceDark 方法处理夜间模式</span></span><br><span class="line">        pushStagingDisplayListChanges(observer, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDisplayList) &#123;</span><br><span class="line">        info.out.hasFunctors |= mDisplayList-&gt;hasFunctor();</span><br><span class="line">        <span class="comment">// 递归调用子 Node 的 prepareTreeImpl 方法</span></span><br><span class="line">        <span class="keyword">bool</span> isDirty = mDisplayList-&gt;prepareListAndChildren(</span><br><span class="line">                observer, info, childFunctorsNeedLayer,</span><br><span class="line">                [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info,</span><br><span class="line">                   <span class="keyword">bool</span> functorsNeedLayer) &#123;</span><br><span class="line">                    child-&gt;prepareTreeImpl(observer, info, functorsNeedLayer);</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">if</span> (isDirty) &#123;</span><br><span class="line">            damageSelf(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 重要，把 info.disableForceDark 恢复回原来的值，不让它影响 Tree 中同级的其他 RenderNode</span></span><br><span class="line">    <span class="comment">// 但是本 RenderNode 的子节点还是会受影响的，这就是为什么父 view 关闭了夜间模式，子 view 也会受影响的原因</span></span><br><span class="line">    <span class="comment">// 因为还原 info.disableForceDark 操作是在遍历子节点之后执行的</span></span><br><span class="line">    <span class="keyword">if</span> (!mProperties.getAllowForceDark()) &#123;</span><br><span class="line">        info.disableForceDark--;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本文到目前为止，总算把 Android Q 夜间模式实现原理梳理了一遍，总的来说实现不算复杂，说白了就是把 paint 中的颜色转换一下或者叠加一个 colorfilter，虽然中间还有关联知识没有细说，如 RenderThread、DisplayList、RenderNode 等图形相关的概念，限于文章大小，请读者自行了解</p><p>另外，由于水平有限，难免文中有错漏之处，若哪里写的不对，请大家及时指出，蟹蟹啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;随着 Android Q 发布，「黑暗模式」或者说是「夜间模式」终于在此版本中得到了支持，官方介绍见：&lt;a href=&quot;https://developer.android.com/guide/topics/ui/look-and-feel/darktheme&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.android.com/guide/topics/ui/look-and-feel/darktheme&lt;/a&gt;，再看看效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.hanschen.site/master/2019-10-21-17-21-50.png&quot; alt=&quot;2019-10-21-17-21-50.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实这个功能魅族在两年前就已支持，不得不说 Android 有点落后了，今天我们就来看看原生是怎么实现全局夜间模的吧&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何顺滑地查看 Android Native 代码</title>
    <link href="http://blog.hanschen.site/2019/10/11/aosp-native-ide/"/>
    <id>http://blog.hanschen.site/2019/10/11/aosp-native-ide/</id>
    <published>2019-10-10T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>使用 Android Studio 查看 Android Framework 代码体验非常好，无论是索引还是界面都让人很满意，但是当你跟踪代码，发现进入 native 逻辑时，就会发现 Android Studio 对 native 代码的支持非常不好，不能索引不支持符号搜索不能跳转等，这些让人非常抓狂。那么如何能在 IDE 愉快地查看 native 代码呢？在 Windows 上，Source Insight 的表现也很好，但苦于只有 Windows 平台支持且界面不好，经过一番折腾，还真是找到了方法，下面我们将一步一步打造丝滑的  native 代码阅读环境。</p><a id="more"></a><p>先看一下效果：</p><p><img src="http://image.hanschen.site/master/2019-10-11-15-02-40.gif" alt="2019-10-11-15-02-40.gif"></p><h1 id="2-CMake"><a href="#2-CMake" class="headerlink" title="2. CMake"></a>2. CMake</h1><p>能让 IDE 正确地建立索引，我们需要让 IDE 能正确地知道源文件、头文件、宏定义等各种数据，庆幸的是，我们发现 AOSP 在编译过程中，可以帮我们生成这些数据，详见：<a href="http://androidxref.com/9.0.0_r3/xref/build/soong/docs/clion.md" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/build/soong/docs/clion.md</a></p><p>通过文档我们可知，只需要按照以下步骤完成一次编译，即可自动生成各模块对应的 CMake 文件。至于 Cmake 文件是什么，这里就不做赘述了，大家可以自行了解。</p><ol><li>打开以下两个开关，CMakeLists.txt 就会根据编译环境自动生成</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SOONG_GEN_CMAKEFILES=1</span><br><span class="line"><span class="built_in">export</span> SOONG_GEN_CMAKEFILES_DEBUG=1</span><br></pre></td></tr></table></figure><ol start="2"><li>启动编译</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j16</span><br></pre></td></tr></table></figure><p>或者只编译你需要的模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make frameworks/native/service/libs/ui</span><br></pre></td></tr></table></figure><p>生成的文件存放在 out 目录，比如刚刚编译的 libui 模块对应的路径为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out/development/ide/clion/frameworks/native/libs/ui/libui-arm64-android/CMakeLists.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>合并多个模块</li></ol><p>生成了 CMake 后，我们发现，CMake 文件是按模块生成的。这样的话，会导致 IDE 只能单独导入一个模块，而我们平时不可能只看一个模块的代码，如果把多个模块都 include 进来呢？<br>我们可以在 <code>out/development/ide/clion</code> 路径新建一个 <code>CMakeLists.txt</code> 文件，并添加一下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span>)</span><br><span class="line"><span class="comment"># 指定工程名，随意</span></span><br><span class="line"><span class="keyword">project</span>(aosp)</span><br><span class="line"><span class="comment"># 把你需要的模块通过 add_subdirectory 添加进来，注意子目录必须也包含 CMakeLists.txt 文件</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(frameworks/native)</span><br><span class="line"><span class="comment">#add_subdirectory(frameworks/base/core/jni/libandroid_runtime-arm64-android)</span></span><br></pre></td></tr></table></figure><p>这样，我们就把多个模块合并在一起了，用 IDE 去打开这个总的 CMake 文件即可</p><h1 id="3-导入-IDE"><a href="#3-导入-IDE" class="headerlink" title="3. 导入 IDE"></a>3. 导入 IDE</h1><p>只要生成 CMake 文件后，剩下的事情就好办了，现在能识别 CMake 工程的 IDE 非常多，大家可以根据个人喜好选择，如：</p><ul><li>CLion</li><li>Eclipse</li><li>Visual Studio</li><li>…</li></ul><p>这里以 CLion 为例讲一下如何导入</p><ol><li>打开 CLion</li><li>选择「New CMake Project from Sources」</li><li>指定包含 <code>CMakeLists.txt</code> 的目录，如我们在上一个步骤中说的 <code>out/development/ide/clion</code>（这个目录的 CMakeLists.txt 包含了多个模块，还记得吗？）</li><li>选择「Open Existing Project」</li><li>Enjoy your journey …</li></ol><p>当然，CLion 也有一个缺点，收费！！如何能免费使用就看大家各显神通了</p><h1 id="4-遇到的一些问题"><a href="#4-遇到的一些问题" class="headerlink" title="4. 遇到的一些问题"></a>4. 遇到的一些问题</h1><ul><li>生成的 CMakeLists.txt 里指定路径可能会使用绝对路径，如： <code>set(ANDROID_ROOT /Volumes/AndroidSource/M1882_QOF7_base)</code>，这里大家要注意，如果把 CMakeLists.txt 拷贝到别的工程使用，记得修正一下路径</li><li>Mac 用户留意，如果你的 CMakeLists.txt 是从 linux 平台生成拷贝过来的，生成的 CMakeLists.txt 里指定的 c++ 编译器 <code>set(CMAKE_CXX_COMPILER &quot;${ANDROID_ROOT}/prebuilts/clang/host/linux-x86/clang-3977809/bin/clang++&quot;)</code> 这里指定的是 linux-x86 的编译器，记得替换成 <code>darwin-x86</code>，如果对应目录下没有 clang++，那就从 AOSP 源码拷一个吧</li><li>如果 CMake 中列出的源文件在工程中找不到，会导致 CLion 停止索引，如果出现不一致的时候，移除 CMake 中源文件的声明即可</li></ul><p>如果使用遇到其他问题，欢迎联系告知，谢谢</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>所谓工欲善其事，必先利其器。通过这种方法建立的索引包含了 AOSP 所有模块，最重要是它还会根据编译环境，把相关 FLAGS 和宏都设置好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;使用 Android Studio 查看 Android Framework 代码体验非常好，无论是索引还是界面都让人很满意，但是当你跟踪代码，发现进入 native 逻辑时，就会发现 Android Studio 对 native 代码的支持非常不好，不能索引不支持符号搜索不能跳转等，这些让人非常抓狂。那么如何能在 IDE 愉快地查看 native 代码呢？在 Windows 上，Source Insight 的表现也很好，但苦于只有 Windows 平台支持且界面不好，经过一番折腾，还真是找到了方法，下面我们将一步一步打造丝滑的  native 代码阅读环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AOSP 编译和烧写</title>
    <link href="http://blog.hanschen.site/2019/09/12/aosp_compile_and_flash/"/>
    <id>http://blog.hanschen.site/2019/09/12/aosp_compile_and_flash/</id>
    <published>2019-09-11T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>很多 Android 开发者都会希望编译 Android 源码并刷进自己的手机里面，但网上教程很多都仅仅是告诉你 lunch、make 等等，但你手里有一台设备时却发现，你编译出的镜像由于驱动关系是不能直接烧进手机的。这里整理了一下步骤，帮助大家可以按照流程编译并烧写镜像。</p><a id="more"></a><p>本篇文章以 <strong>Pixel 2 &amp;&amp; Android 10</strong> 为例</p><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h1><p>这块没啥说，官方教程就够了，参考：<a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">https://source.android.com/setup/build/initializing</a> 就行了</p><h1 id="3-源码下载"><a href="#3-源码下载" class="headerlink" title="3. 源码下载"></a>3. 源码下载</h1><ol><li>根据 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">https://developers.google.com/android/drivers</a> 选择一个设备对应 Android 版本号和驱动，比如我们选择：Android 10.0.0 (QP1A.190711.020)，下载驱动，记住 <strong>Build 号</strong><br><img src="http://image.hanschen.site/master/2019-9-12-16-53-40.png" alt="2019-9-12-16-53-40.png"></li></ol><ol start="2"><li><p>在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers</a> 查找 QP1A.190711.020 对应的分支：android-10.0.0_r2，记住<strong>分支名</strong><br><img src="http://image.hanschen.site/master/2019-9-12-16-56-41.png" alt="2019-9-12-16-56-41.png"></p></li><li><p>下载 AOSP 源码<br>注意在下载 aosp 前要安装 repo 工具，参考：<a href="https://source.android.com/setup/build/downloading" target="_blank" rel="noopener">https://source.android.com/setup/build/downloading</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir Pixel2</span><br><span class="line"><span class="built_in">cd</span> Pixel2</span><br><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r2 --depth=1</span><br><span class="line">repo sync -j8</span><br><span class="line">repo start android-10.0.0_r2 --all</span><br></pre></td></tr></table></figure></li><li><p>把步骤1中选中的两个驱动下载到 aosp 源码根目录并解压</p></li><li><p>分别执行解压后的文件，注意，执行后要同意 License，确保正确解压到 aosp 根目录的 vendor 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./extract-qcom-walleye.sh</span><br><span class="line">./extract-google_devices-walleye.sh</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-源码编译"><a href="#4-源码编译" class="headerlink" title="4. 源码编译"></a>4. 源码编译</h1><ol><li>在 aosp 源码根目录执行：source build/envsetup.sh（注意，执行前终端请选bash，不要使用zsh等，在终端键入bash回车即可）</li><li>在 aosp 源码根目录执行：lunch</li><li>选择对应的版本，比如 Pixel2 就选择：aosp_walleye-userdebug</li><li>执行：make -j8</li></ol><h1 id="5-镜像烧写"><a href="#5-镜像烧写" class="headerlink" title="5. 镜像烧写"></a>5. 镜像烧写</h1><ol><li>编译完后，执行：<code>export ANDROID_PRODUCT_OUT=/home/chenhang/source/Pixel2/out/target/product/walleye</code></li><li>执行：<code>fastboot flashall -w</code></li><li>烧写完成后，执行：<code>fastboot reboot</code></li></ol><h1 id="6-Gapps-安装"><a href="#6-Gapps-安装" class="headerlink" title="6. Gapps 安装"></a>6. Gapps 安装</h1><p>编译出来的 aosp 默认没有 google 全家桶，可以通过以下方式进行安装</p><ol><li>在 <a href="https://opengapps.org/" target="_blank" rel="noopener">https://opengapps.org/</a> 根据系统版本、芯片类型选择需要的 Gapps 全家桶，可以选 stock 版本</li><li>下载后把全家桶 push 到手机 sdcard（不用解压）</li><li>在 <a href="https://twrp.me/devices/" target="_blank" rel="noopener">https://twrp.me/devices/</a> 搜索你的设备，如： <a href="https://twrp.me/google/googlepixel2.html" target="_blank" rel="noopener">https://twrp.me/google/googlepixel2.html</a><br><img src="http://image.hanschen.site/master/2019-9-12-17-3-22.png" alt="2019-9-12-17-3-22.png"></li><li>下载 twrp.img 后根据截图中的命令，把 twrp 加载到手机， 选择 install 刷入 twrp.zip (这是一个 recovery 版本)，重启后，通过 adb reboot recovery 进入 twrp 的recovery 系统</li><li>在手机上选择 install， 选择步骤2中 push 到手机 sdcard 的全家桶，安装结束后选择擦除 dalvik cache 和 cache，重启即可</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;很多 Android 开发者都会希望编译 Android 源码并刷进自己的手机里面，但网上教程很多都仅仅是告诉你 lunch、make 等等，但你手里有一台设备时却发现，你编译出的镜像由于驱动关系是不能直接烧进手机的。这里整理了一下步骤，帮助大家可以按照流程编译并烧写镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers 手册</title>
    <link href="http://blog.hanschen.site/2017/04/08/protobuf3/"/>
    <id>http://blog.hanschen.site/2017/04/08/protobuf3/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。</p><p>至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 <code>protobuf</code> 来定义我们的交互协议，包括 <code>.proto</code> 的语法以及如何根据proto文件生成相应的代码。本文基于<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3</a>，读者也可以点击了解<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a></p><a id="more"></a><h1 id="proto3语法"><a href="#proto3语法" class="headerlink" title="proto3语法"></a>proto3语法</h1><h2 id="定义一个-Message"><a href="#定义一个-Message" class="headerlink" title="定义一个 Message"></a>定义一个 Message</h2><p>首先我们来定义一个 Search 请求，在这个请求里面，我们需要给服务端发送三个信息：</p><ul><li>query：查询条件</li><li>page_number：你想要哪一页数据</li><li>result_per_page：每一页有多少条数据</li></ul><p>于是我们可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 指定使用proto3，如果不指定的话，编译器会使用proto2去编译</span><br><span class="line">syntax = &quot;proto3&quot;; //[proto2|proto3]</span><br><span class="line"></span><br><span class="line">message SearchRequests &#123;</span><br><span class="line">    // 定义SearchRequests的成员变量，需要指定：变量类型、变量名、变量Tag</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2;</span><br><span class="line">    int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义多个-message-类型"><a href="#定义多个-message-类型" class="headerlink" title="定义多个 message 类型"></a>定义多个 message 类型</h2><p>一个 proto 文件可以定义多个 message ，比如我们可以在刚才那个 proto 文件中把服务端返回的消息结构也一起定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2;</span><br><span class="line">    int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">    repeated string result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>message 可以嵌套定义，比如 message 可以定义在另一个 message 内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">    message Result &#123;</span><br><span class="line">        string url = 1;</span><br><span class="line">        string title = 2;</span><br><span class="line">        repeated string snippets = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Result results = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在 message 内部的 message 可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">    SearchResponse.Result result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义变量类型"><a href="#定义变量类型" class="headerlink" title="定义变量类型"></a>定义变量类型</h2><p>在刚才的例子之中，我们使用了2个<code>标准值类型</code>： string 和 int32，除了这些标准类型之外，变量的类型还可以是复杂类型，比如自定义的<code>枚举</code>和自定义的 <code>message</code></p><p>这里我们把标准类型列举一下protobuf内置的标准类型以及跟各平台对应的关系：</p><table><thead><tr><th align="left">.proto</th><th align="left">说明</th><th align="left">C++</th><th align="left">Java</th><th align="left">Python</th><th align="left">Go</th><th align="left">Ruby</th><th align="left">C#</th><th align="left">PHP</th></tr></thead><tbody><tr><td align="left">double</td><td align="left"></td><td align="left">double</td><td align="left">double</td><td align="left">float</td><td align="left">float64</td><td align="left">Float</td><td align="left">double</td><td align="left">float</td></tr><tr><td align="left">float</td><td align="left"></td><td align="left">float</td><td align="left">float</td><td align="left">float</td><td align="left">float32</td><td align="left">Float</td><td align="left">float</td><td align="left">float</td></tr><tr><td align="left">int32</td><td align="left">使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint32</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">int64</td><td align="left">使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint64</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">uint32</td><td align="left">使用变长编码</td><td align="left">uint32</td><td align="left">int</td><td align="left">int/long</td><td align="left">uint32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">uint64</td><td align="left">使用变长编码</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sint32</td><td align="left">使用变长编码，带符号的int类型，对负数编码比int32高效</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sint64</td><td align="left">使用变长编码，带符号的int类型，对负数编码比int64高效</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">fixed32</td><td align="left">4字节编码， 如果变量经常大于$ 2^{28} $ 的话，会比uint32高效</td><td align="left">uint32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">fixed64</td><td align="left">8字节编码， 如果变量经常大于$ 2^{56} $ 的话，会比uint64高效</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sfixed32</td><td align="left">4字节编码</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sfixed64</td><td align="left">8字节编码</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">bool</td><td align="left"></td><td align="left">bool</td><td align="left">boolean</td><td align="left">bool</td><td align="left">bool</td><td align="left">TrueClass/FalseClass</td><td align="left">bool</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td align="left">必须包含utf-8编码或者7-bit ASCII text</td><td align="left">string</td><td align="left">String</td><td align="left">str/unicode</td><td align="left">string</td><td align="left">String (UTF-8)</td><td align="left">string</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td align="left">任意的字节序列</td><td align="left">string</td><td align="left">ByteString</td><td align="left">str</td><td align="left">[]byte</td><td align="left">String (ASCII-8BIT)</td><td align="left">ByteString</td><td align="left">string</td></tr></tbody></table><p>补充说明：</p><ul><li>In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.</li><li>In all cases, setting values to a field will perform type checking to make sure it is valid.</li><li>64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">2</a>.</li><li>Python strings are represented as unicode on decode but can be str if an ASCII string is given (this is subject to change).</li><li>Integer is used on 64-bit machines and string is used on 32-bit machines.</li></ul><p>关于标准值类型，还可以参考<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">Scalar Value Types</a></p><p>如果你想了解这些数据是怎么序列化和反序列化的，可以点击 <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Protocol Buffer Encoding</a> 了解更多关于protobuf编码内容。</p><h2 id="分配Tag"><a href="#分配Tag" class="headerlink" title="分配Tag"></a>分配Tag</h2><p>每一个变量在message内都需要自定义一个<strong>唯一的数字Tag</strong>，protobuf会根据Tag从数据中查找变量对应的位置，具体原理跟protobuf的<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">二进制数据格式</a>有关。Tag一旦指定，以后更新协议的时候也不能修改，否则无法对旧版本兼容。</p><p>Tag的取值范围最小是1，最大是$ 2^{29} $-1，但 19000~19999 是 protobuf 预留的，用户不能使用。</p><p>虽然 Tag 的定义范围比较大，但不同 Tag 也会对 protobuf 编码带来一些影响：</p><ul><li>1 ~ 15：单字节编码</li><li>16 ~ 2047：双字节编码</li></ul><p>使用频率高的变量最好设置为1 ~ 15，这样可以减少编码后的数据大小，但由于Tag一旦指定不能修改，所以为了以后扩展，也记得为未来保留一些 1 ~ 15 的 Tag</p><h2 id="指定变量规则"><a href="#指定变量规则" class="headerlink" title="指定变量规则"></a>指定变量规则</h2><p>在 proto3 中，可以给变量指定以下两个规则：</p><ul><li><code>singular</code>：0或者1个，但不能多于1个</li><li><code>repeated</code>：任意数量（包括0）</li></ul><p>当构建 message 的时候，build 数据的时候，会检测设置的数据跟规则是否匹配</p><p>在proto2中，规则为：</p><ul><li>required：必须有一个</li><li>optional：0或者1个</li><li>repeated：任意数量（包括0）</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用<code>//</code>表示注释开头，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2; // Which page number do we want</span><br><span class="line">    int32 result_per_page = 3; // Number of results to return per page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保留变量不被使用"><a href="#保留变量不被使用" class="headerlink" title="保留变量不被使用"></a>保留变量不被使用</h2><p>上面我们说到，一旦 Tag 指定后就不能变更，这就会带来一个问题，假如在版本1的协议中，我们有个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 number = 1；</span><br></pre></td></tr></table></figure><p>在版本2中，我们决定废弃对它的使用，那我们应该如何修改协议呢？注释掉它？删除掉它？如果把它删除了，后来者很可能在定义新变量的时候，使新的变量 Tag = 1 ，这样会导致协议不兼容。那有没有办法规避这个问题呢？我们可以用 <code>reserved</code> 关键字，当一个变量不再使用的时候，我们可以把它的变量名或 Tag 用 <code>reserved</code> 标注，这样，当这个 Tag 或者变量名字被重新使用的时候，编译器会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    // 注意，同一个 reserved 语句不能同时包含变量名和 Tag </span><br><span class="line">    reserved 2, 15, 9 to 11;</span><br><span class="line">    reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>当解析 message 时，如果被编码的 message 里没有包含某些变量，那么根据类型不同，他们会有不同的默认值：</p><ul><li>string：默认是空的字符串</li><li>byte：默认是空的bytes</li><li>bool：默认为false</li><li>numeric：默认为0</li><li>enums：定义在第一位的枚举值，也就是0</li><li>messages：根据生成的不同语言有不同的表现，参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">generated code guide </a></li></ul><p>注意，收到数据后反序列化后，对于标准值类型的数据，比如bool，如果它的值是 false，那么我们无法判断这个值是对方设置的，还是对方压根就没给这个变量设置值。</p><h2 id="定义枚举-Enumerations"><a href="#定义枚举-Enumerations" class="headerlink" title="定义枚举 Enumerations"></a>定义枚举 Enumerations</h2><p>在 protobuf 中，我们也可以定义枚举，并且使用该枚举类型，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2; // Which page number do we want</span><br><span class="line">    int32 result_per_page = 3; // Number of results to return per page</span><br><span class="line">    enum Corpus &#123;</span><br><span class="line">        UNIVERSAL = 0;</span><br><span class="line">        WEB = 1;</span><br><span class="line">        IMAGES = 2;</span><br><span class="line">        LOCAL = 3;</span><br><span class="line">        NEWS = 4;</span><br><span class="line">        PRODUCTS = 5;</span><br><span class="line">        VIDEO = 6;</span><br><span class="line">    &#125;</span><br><span class="line">    Corpus corpus = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举定义在一个消息内部或消息外部都是可以的，如果枚举是 定义在 message 内部，而其他 message 又想使用，那么可以通过 <code>MessageType.EnumType</code> 的方式引用。定义枚举的时候，我们要保证<strong>第一个枚举值必须是0</strong>，枚举值不能重复，除非使用 <code>option allow_alias = true</code> 选项来开启别名。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">    option allow_alias = true;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    STARTED = 1;</span><br><span class="line">    RUNNING = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举值的范围是32-bit integer，但因为枚举值使用变长编码，所以不推荐使用负数作为枚举值，因为这会带来效率问题。</p><h2 id="如何引用其他-proto-文件"><a href="#如何引用其他-proto-文件" class="headerlink" title="如何引用其他 proto 文件"></a>如何引用其他 proto 文件</h2><p>在proto语法中，有两种引用其他 proto 文件的方法： <code>import</code> 和 <code>import public</code>，这两者有什么区别呢？下面举个例子说明：<br><img src="http://image.hanschen.site/master/2019-9-2-12-36-49.png" alt="2019-9-2-12-36-49.png"></p><ul><li>在情景1中， my.proto <strong>不能</strong>使用 second.proto 中定义的内容</li><li>在情景2中， my.proto <strong>可以</strong>使用 second.proto 中定义的内容</li><li>情景1和情景2中，my.proto 都可以使用 first.proto</li><li>情景1和情景2中，first.proto 都可以使用 second.proto</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// my.proto</span><br><span class="line">import &quot;first.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// first.proto</span><br><span class="line">//import &quot;second.proto&quot;;</span><br><span class="line">import public &quot;second.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// second.proto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="升级-proto-文件正确的姿势"><a href="#升级-proto-文件正确的姿势" class="headerlink" title="升级 proto 文件正确的姿势"></a>升级 proto 文件正确的姿势</h2><p>升级更改 proto 需要遵循以下原则</p><ul><li>不要修改任何已存在的变量的 Tag</li><li>如果你新增了变量，新生成的代码依然能解析旧的数据，但新增的变量将会变成默认值。相应的，新代码序列化的数据也能被旧的代码解析，但旧代码会自动忽略新增的变量。</li><li>废弃不用的变量用 reserved 标注</li><li>int32、 uint32、 int64、 uint64 和 bool 是相互兼容的，这意味你可以更改这些变量的类型而不会影响兼容性</li><li>sint32 和 sint64 是兼容的，但跟其他类型不兼容</li><li>string 和 bytes 可以兼容，前提是他们都是UTF-8编码的数据</li><li>fixed32 和 sfixed32 是兼容的, fixed64 和 sfixed64是兼容的</li></ul><h2 id="Any-的使用"><a href="#Any-的使用" class="headerlink" title="Any 的使用"></a>Any 的使用</h2><p>Any可以让你在 proto 文件中使用未定义的类型，具体里面保存什么数据，是在上层业务代码使用的时候决定的，使用 Any 必须导入 <code>import google/protobuf/any.proto</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">    repeated google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Oneof-的使用"><a href="#Oneof-的使用" class="headerlink" title="Oneof 的使用"></a>Oneof 的使用</h2><p>Oneof 类似union，如果你的消息中有很多可选字段，而同一个时刻最多仅有其中的一个字段被设置的话，你可以使用oneof来强化这个特性并且节约存储空间，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message LoginReply &#123;</span><br><span class="line">    oneof test_oneof &#123;</span><br><span class="line">        string name = 3;</span><br><span class="line">        string age = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    required string status = 1;</span><br><span class="line">    required string token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，name 和 age 都是 LoginReply 的成员，但不能给他们同时设置值（设置一个oneof字段会自动清理其他的oneof字段）。</p><h2 id="Maps-的使用"><a href="#Maps-的使用" class="headerlink" title="Maps 的使用"></a>Maps 的使用</h2><p>protobuf 支持定义 map 类型的成员，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br><span class="line">// 举例：map&lt;string, Project&gt; projects = 3;</span><br></pre></td></tr></table></figure><ul><li>key_type:必须是string或者int</li><li>value_type：任意类型</li></ul><p>使用 map 要注意：</p><ul><li>Map 类型不能使 repeated</li><li>Map 是无序的</li><li>以文本格式展示时，Map 以 key 来排序</li><li>如果有相同的键会导致解析失败</li></ul><h2 id="Packages-的使用"><a href="#Packages-的使用" class="headerlink" title="Packages 的使用"></a>Packages 的使用</h2><p>为了防止不同消息之间的命名冲突，你可以对特定的.proto文件提指定 package 名字。在定义消息的成员的时候，可以指定包的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 带上包名</span><br><span class="line">    foo.bar.Open open = 1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><p>Options 分为 file-level options（只能出现在最顶层，不能在消息、枚举、服务内部使用）、 message-level options（只能在消息内部使用）、field-level options（只能在变量定义时使用）</p><ul><li>java_package (file option)：指定生成类的包名，如果没有指定此选项，将由关键字package指定包名。此选项只在生成 java 代码时有效</li><li>java_multiple_files (file option)：如果为 true， 定义在最外层的 message 、enum、service 将作为单独的类存在</li><li>java_outer_classname (file option)：指定最外层class的类名，如果不指定，将会以文件名作为类名</li><li>optimize_for (file option)：可选有 [SPEED|CODE_SIZE|LITE_RUNTIME] ，分别是效率优先、空间优先，第三个lite是兼顾效率和代码大小，但是运行时需要依赖 libprotobuf-lite</li><li>cc_enable_arenas (file option):启动arena allocation，c++代码使用</li><li>objc_class_prefix (file option)：Objective-C使用</li><li>deprecated (field option)：提示变量已废弃、不建议使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option java_package = &quot;com.example.foo&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_outer_classname = &quot;Ponycopter&quot;;</span><br><span class="line">option optimize_for = CODE_SIZE;</span><br><span class="line">int32 old_field = 6 [deprecated=true];</span><br></pre></td></tr></table></figure><h1 id="定义-Services"><a href="#定义-Services" class="headerlink" title="定义 Services"></a>定义 Services</h1><p>这个其实和gRPC相关，详细可参考：<a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a>， 这里做一个简单的介绍<br>要定义一个服务，你必须在你的 .proto 文件中指定 <code>service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们的服务中定义 <code>rpc</code> 方法，指定它们的请求的和响应类型。<code>gRPC</code> 允许你定义4种类型的 service 方法</p><h2 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h2><p>客户端使用 Stub 发送请求到服务器并等待响应返回，就像平常的函数调用一样，这是一个阻塞型的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the feature at a given position.</span><br><span class="line">rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h2><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在响应类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the Features available within the given Rectangle.  Results are</span><br><span class="line">// streamed rather than returned at once (e.g. in a response message with a</span><br><span class="line">// repeated field), as the rectangle may cover a large area and contain a</span><br><span class="line">// huge number of features.</span><br><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h2><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在请求类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of Points on a route being traversed, returning a</span><br><span class="line">// RouteSummary when traversal is completed.</span><br><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h2><p>双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</span><br><span class="line">// while receiving other RouteNotes (e.g. from other users).</span><br><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><p>使用 <code>protoc</code> 工具可以把编写好的 <code>proto</code> 文件“编译”为Java, Python, C++, Go, Ruby, JavaNano, Objective-C,或C#代码， <code>protoc</code> 可以从<a href="https://developers.google.com/protocol-buffers/docs/downloads" target="_blank" rel="noopener">点击这里</a>进行下载。<code>protoc</code> 的使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>IMPORT_PATH：指定 proto 文件的路径，如果没有指定， protoc 会从当前目录搜索对应的 proto 文件，如果有多个路径，那么可以指定多次<code>--proto_path</code></li><li>指定各语言代码的输出路径<ul><li>–cpp_out：生成c++代码</li><li>java_out ：生成java代码</li><li>python_out ：生成python代码</li><li>go_out ：生成go代码</li><li>ruby_out ：生成ruby代码</li><li>javanano_out ：适合运行在有资源限制的平台（如Android）的java代码</li><li>objc_out ：生成 Objective-C代码</li><li>csharp_out ：生成C#代码</li><li>php_out ：生成PHP代码</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。&lt;/p&gt;
&lt;p&gt;至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 &lt;code&gt;protobuf&lt;/code&gt; 来定义我们的交互协议，包括 &lt;code&gt;.proto&lt;/code&gt; 的语法以及如何根据proto文件生成相应的代码。本文基于&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proto3&lt;/a&gt;，读者也可以点击了解&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proto2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://blog.hanschen.site/categories/gRPC/"/>
    
    
      <category term="protobuf" scheme="http://blog.hanschen.site/tags/protobuf/"/>
    
      <category term="gRPC" scheme="http://blog.hanschen.site/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰模式</title>
    <link href="http://blog.hanschen.site/2017/03/09/pattern_decorator/"/>
    <id>http://blog.hanschen.site/2017/03/09/pattern_decorator/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责，就增加功能来说装饰模式比生成子类更为灵活。它通过创建一个包装对象，也就是装饰来包裹真实的对象</p><h1 id="情景举例"><a href="#情景举例" class="headerlink" title="情景举例"></a>情景举例</h1><p>我们先来分析这样一个画图形的需求：</p><ol><li>它能绘制各种背景，如红色、蓝色、绿色</li><li>它能绘制形状，如三角形，正方形，圆形</li><li>它能给形状加上阴影</li></ol><p>就先列这三个简单的需求吧，下面让我们比较下各种实现的优缺点</p><h1 id="丑陋的实现"><a href="#丑陋的实现" class="headerlink" title="丑陋的实现"></a>丑陋的实现</h1><p>来看看我们用继承是如何实现的，首先，抽象出一个<code>Shape</code>接口我想大家都不会有意见的是不是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制图形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义各种情况下的子类，结构如下，看到这么多的子类，是不是有点要爆炸的感觉？真是想想都可怕<br><img src="http://image.hanschen.site/master/2019-9-2-12-35-9.png" alt="2019-9-2-12-35-9.png"></p><p>而且如果再新增一种需求，比如现在要画椭圆，那么维护的人员估计就要爆粗了吧？</p><a id="more"></a><p>为了避免写出上面的代码，聪明的童鞋们可能会提出第二种方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeImpl</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Type &#123;</span><br><span class="line">        Circle,</span><br><span class="line">        Square,</span><br><span class="line">        Trilatera</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Color &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Green,</span><br><span class="line">        Blue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type    type;</span><br><span class="line">    <span class="keyword">private</span> Color   color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShadow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shadow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShadow</span><span class="params">(<span class="keyword">boolean</span> shadow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shadow = shadow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2017/3/9 根据属性情况画出不同的图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，根据不同的画图需求，只需要设置不同的属性就可以了，这样确实避免了类爆炸增长的问题，但这种方式违反了开放封闭原则，比如画正方形的方式变了，需要对<code>ShapeImpl</code>进行修改，或者如果新增需求，如画椭圆，也需要对<code>ShapeImpl</code>进行修改。而且这个类不方便扩展，子类将继承一些对自身并不合适的方法。</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><blockquote><p>装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责</p></blockquote><p>以下情况使用Decorator模式：</p><ul><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li><li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类</li></ul><p>但这种灵活也会带来一些缺点，这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂</p><p>下面来看看装饰模式的结构：<br><img src="http://image.hanschen.site/master/2019-9-2-12-35-32.png" alt="2019-9-2-12-35-32.png"></p><ol><li>Component抽象组件，是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。（注：在装饰模式中，必然有一个最基本、最核心、最原始的接口或者抽象类充当Component抽象组件）</li><li>ConcreteComponent具体组件，是最核心、最原始、最基本的接口或抽象类的实现，我们需要装饰的就是它</li><li>Decorator装饰角色， 一般是一个抽象类，实现接口或者抽象方法，它的属性里必然有一个private变量指向Component抽象组件。</li><li>具体装饰角色，如上图中的ConcreteDecoratorA和ConcreteDecoratorB，我们要把我们最核心的、最原始的、最基本的东西装饰成其它东西。</li></ol><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说了一堆结构和示例代码，但大家可能还是不太好理解，下面用装饰模式来重新实现画图的功能</p><h2 id="用装饰模式实现需求"><a href="#用装饰模式实现需求" class="headerlink" title="用装饰模式实现需求"></a>用装饰模式实现需求</h2><p>先上结构图<br><img src="http://image.hanschen.site/master/2019-9-2-12-35-51.png" alt="2019-9-2-12-35-51.png"></p><p>首先定义可动态扩展对象的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制图形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的组件，每一个组件代表一个形状</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"正方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trilateral</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义可装饰者的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的装饰者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blue</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 蓝色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Green</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 绿色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Red</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 红色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shadow</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shadow</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 有阴影"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在让我们看看具体怎么使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正方形 红色 有阴影</span></span><br><span class="line">        Shape shape = <span class="keyword">new</span> Square();</span><br><span class="line">        shape = <span class="keyword">new</span> Red(shape);</span><br><span class="line">        shape = <span class="keyword">new</span> Shadow(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//圆形 绿色</span></span><br><span class="line">        shape = <span class="keyword">new</span> Circle();</span><br><span class="line">        shape = <span class="keyword">new</span> Green(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形 蓝色 有阴影</span></span><br><span class="line">        shape = <span class="keyword">new</span> Trilateral();</span><br><span class="line">        shape = <span class="keyword">new</span> Blue(shape);</span><br><span class="line">        shape = <span class="keyword">new</span> Shadow(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，装饰模式是非常灵活的，通过不同的装饰，实现不同的效果</p><h1 id="装饰模式的应用举例"><a href="#装饰模式的应用举例" class="headerlink" title="装饰模式的应用举例"></a>装饰模式的应用举例</h1><p>这里再列举一些用到了装饰模式的情景，童鞋们可以根据这些场景加深对装饰模式的理解</p><ul><li>Java中<code>IO</code>设计</li><li>Android中<code>Context</code>和<code>ContextWrapper</code>的设计</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰模式是为已有功能动态地添加功能的一种方式，它把每个要装饰的功能放在单独的类中，并让这个类包括要装饰的对象，有效地把核心职能和装饰功能区分开了。但它带来灵活的同时，也容易导致别人不了解自己的设计方式，不知如何使用。就像Java中I/O库，人们第一次接触的时候，往往无法轻易理解它。这其中的平衡取舍，就看自己咯</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责，就增加功能来说装饰模式比生成子类更为灵活。它通过创建一个包装对象，也就是装饰来包裹真实的对象&lt;/p&gt;
&lt;h1 id=&quot;情景举例&quot;&gt;&lt;a href=&quot;#情景举例&quot; class=&quot;headerlink&quot; title=&quot;情景举例&quot;&gt;&lt;/a&gt;情景举例&lt;/h1&gt;&lt;p&gt;我们先来分析这样一个画图形的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它能绘制各种背景，如红色、蓝色、绿色&lt;/li&gt;
&lt;li&gt;它能绘制形状，如三角形，正方形，圆形&lt;/li&gt;
&lt;li&gt;它能给形状加上阴影&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就先列这三个简单的需求吧，下面让我们比较下各种实现的优缺点&lt;/p&gt;
&lt;h1 id=&quot;丑陋的实现&quot;&gt;&lt;a href=&quot;#丑陋的实现&quot; class=&quot;headerlink&quot; title=&quot;丑陋的实现&quot;&gt;&lt;/a&gt;丑陋的实现&lt;/h1&gt;&lt;p&gt;来看看我们用继承是如何实现的，首先，抽象出一个&lt;code&gt;Shape&lt;/code&gt;接口我想大家都不会有意见的是不是？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; HansChen&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 绘制图形&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后我们定义各种情况下的子类，结构如下，看到这么多的子类，是不是有点要爆炸的感觉？真是想想都可怕&lt;br&gt;&lt;img src=&quot;http://image.hanschen.site/master/2019-9-2-12-35-9.png&quot; alt=&quot;2019-9-2-12-35-9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且如果再新增一种需求，比如现在要画椭圆，那么维护的人员估计就要爆粗了吧？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="http://blog.hanschen.site/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="包装器模式" scheme="http://blog.hanschen.site/tags/%E5%8C%85%E8%A3%85%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="http://blog.hanschen.site/2017/03/01/pattern_bridge/"/>
    <id>http://blog.hanschen.site/2017/03/01/pattern_bridge/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h1><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>现在我们要实现这样一个功能：发送消息。从业务上看，消息又分成普通消息、加急消息和特急消息多种，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加“加急”字样，而特急消息除了添加特急外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内短消息、手机短消息、邮件等等。现在要实现这样的发送提示消息的功能，该如何实现呢？</p><a id="more"></a><h2 id="不用模式的解决方案"><a href="#不用模式的解决方案" class="headerlink" title="不用模式的解决方案"></a>不用模式的解决方案</h2><h3 id="实现简化版本"><a href="#实现简化版本" class="headerlink" title="实现简化版本"></a>实现简化版本</h3><p>先实现一个简单点的版本：消息只是实现发送普通消息，发送的方式先实现系统内短消息和邮件。其它的功能，等这个版本完成过后，再继续添加，这样先把问题简单化，实现起来会容易一点。由于发送普通消息会有两种不同的实现方式，为了让外部能统一操作，因此，把消息设计成接口，然后由两个不同的实现类，分别实现系统内短消息方式和邮件发送消息的方式。此时系统结构如下：<br><img src="http://image.hanschen.site/master/2019-9-2-12-30-41.png" alt="2019-9-2-12-30-41.png"></p><p>先来看看消息的统一接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来分别看看两种实现方式，这里只是为了示意，并不会真的去发送Email和站内短消息，先看站内短消息的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageSMS</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，实现以Email的方式发送普通消息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageEmail</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现发送加急消息"><a href="#实现发送加急消息" class="headerlink" title="实现发送加急消息"></a>实现发送加急消息</h3><p>上面的实现，看起来很简单，对不对。接下来，添加发送加急消息的功能，也有两种发送的方式，同样是站内短消息和Email的方式。<br>加急消息的实现跟普通消息不同，加急消息会自动在消息上添加加急，然后再发送消息；另外加急消息会提供监控的方法，让客户端可以随时通过这个方法来了解对于加急消息处理的进度，比如：相应的人员是否接收到这个信息，相应的工作是否已经开展等等。因此加急消息需要扩展出一个新的接口，除了基本的发送消息的功能，还需要添加监控的功能，这个时候，系统的结构如图所示：<br><img src="http://image.hanschen.site/master/2019-9-2-12-31-39.png" alt="2019-9-2-12-31-39.png"></p><p>先看看扩展出来的加急消息的接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">watch</span><span class="params">(String messageId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的实现方式还是发送站内短消息和Email两种，同样需要两个实现类来分别实现这两种方式，先看站内短消息的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageSMS</span> <span class="keyword">implements</span> <span class="title">UrgencyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Emai的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageEmail</span> <span class="keyword">implements</span> <span class="title">UrgencyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，在实现加急消息发送的功能上，可能会使用前面发送不同消息的功能，也就是让实现加急消息处理的对象继承普通消息的相应实现，这里为了让结构简单一点，清晰一点，所以没有这样做。</p><h2 id="有何问题"><a href="#有何问题" class="headerlink" title="有何问题"></a>有何问题</h2><p>上面这样实现，好像也能满足基本的功能要求，可是这么实现好不好呢？有没有什么问题呢？<br>我们继续向下来添加功能实现，为了简洁，就不再去进行代码示意了，通过实现的结构示意图就可以看出实现上的问题。</p><h3 id="继续添加特急消息的处理"><a href="#继续添加特急消息的处理" class="headerlink" title="继续添加特急消息的处理"></a>继续添加特急消息的处理</h3><p>特急消息不需要查看处理进程，只要没有完成，就直接催促，也就是说，对于特急消息，在普通消息的处理基础上，需要添加催促的功能。而特急消息、还有催促的发送方式，相应的实现方式还是发送站内短消息和Email两种，此时系统的结构如图所示：<br><img src="http://image.hanschen.site/master/2019-9-2-12-32-9.png" alt="2019-9-2-12-32-9.png"></p><p>仔细观察上面的系统结构示意图，会发现一个很明显的问题，那就是：通过这种继承的方式来扩展消息处理，会非常不方便。<br>你看，实现加急消息处理的时候，必须实现站内短消息和Email两种处理方式，因为业务处理可能不同；在实现特急消息处理的时候，又必须实现站内短消息和Email这两种处理方式。<br>这意味着，以后每次扩展一下消息处理，都必须要实现这两种处理方式，是不是很痛苦，这还不算完，如果要添加新的实现方式呢？继续向下看吧。</p><h3 id="继续添加发送手机消息的处理方式"><a href="#继续添加发送手机消息的处理方式" class="headerlink" title="继续添加发送手机消息的处理方式"></a>继续添加发送手机消息的处理方式</h3><p>如果看到上面的实现，你还感觉问题不是很大的话，继续完成功能，添加发送手机消息的处理方式<br>仔细观察现在的实现，如果要添加一种新的发送消息的方式，是需要在每一种抽象的具体实现里面，都要添加发送手机消息的处理的。也就是说：发送普通消息、加急消息和特急消息的处理，都可以通过手机来发送。这就意味着，需要添加三个实现。此时系统结构如图所示：<br><img src="http://image.hanschen.site/master/2019-9-2-12-32-31.png" alt="2019-9-2-12-32-31.png"></p><p>这下能体会到这种实现方式的大问题了吧。</p><h3 id="小结一下出现的问题"><a href="#小结一下出现的问题" class="headerlink" title="小结一下出现的问题"></a>小结一下出现的问题</h3><p>采用通过继承来扩展的实现方式，有个明显的缺点：扩展消息的种类不太容易，不同种类的消息具有不同的业务，也就是有不同的实现，在这种情况下，每个种类的消息，需要实现所有不同的消息发送方式。<br>更可怕的是，如果要新加入一种消息的发送方式，那么会要求所有的消息种类，都要加入这种新的发送方式的实现。<br>要是考虑业务功能上再扩展一下呢？比如：要求实现群发消息，也就是一次可以发送多条消息，这就意味着很多地方都得修改，太恐怖了。<br>那么究竟该如何实现才能既实现功能，又能灵活的扩展呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="桥接模式来解决"><a href="#桥接模式来解决" class="headerlink" title="桥接模式来解决"></a>桥接模式来解决</h2><p>用来解决上述问题的一个合理的解决方案，就是使用桥接模式。那么什么是桥接模式呢？<br>桥接模式定义：</p><blockquote><p>将抽象部分和实现部分分离，使它们都可以独立地变化</p></blockquote><p>应用桥接模式来解决的思路</p><p>仔细分析上面的示例，根据示例的功能要求，示例的变化具有两个维度，一个维度是抽象的消息这边，包括普通消息、加急消息和特急消息，这几个抽象的消息本身就具有一定的关系，加急消息和特急消息会扩展普通消息；另一个维度在具体的消息发送方式上，包括站内短消息、Email和手机短信息，这几个方式是平等的，可被切换的方式。这两个维度一共可以组合出9种不同的可能性来。<br>现在出现问题的根本原因，就在于消息的抽象和实现是混杂在一起的，这就导致了，一个维度的变化，会引起另一个维度进行相应的变化，从而使得程序扩展起来非常困难。<br>要想解决这个问题，就必须把这两个维度分开，也就是将抽象部分和实现部分分开，让它们相互独立，这样就可以实现独立的变化，使扩展变得简单。<br>桥接模式通过引入实现的接口，把实现部分从系统中分离出去；那么，抽象这边如何使用具体的实现呢？肯定是面向实现的接口来编程了，为了让抽象这边能够很方便的与实现结合起来，把顶层的抽象接口改成抽象类，在里面持有一个具体的实现部分的实例。<br>这样一来，对于需要发送消息的客户端而言，就只需要创建相应的消息对象，然后调用这个消息对象的方法就可以了，这个消息对象会调用持有的真正的消息发送方式来把消息发送出去。也就是说客户端只是想要发送消息而已，并不想关心具体如何发送。</p><h2 id="模式结构和说明"><a href="#模式结构和说明" class="headerlink" title="模式结构和说明"></a>模式结构和说明</h2><p>桥接模式的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-12-32-50.png" alt="2019-9-2-12-32-50.png"></p><ul><li>Abstraction：抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。</li><li>RefinedAbstraction：扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。</li><li>Implementor：定义实现部分的接口，这个接口不用和Abstraction里面的方法一致，通常是由Implementor接口提供基本的操作，而Abstraction里面定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的较高层次的操作。</li><li>ConcreteImplementor：真正实现Implementor接口的对象。</li></ul><h2 id="桥接模式示例代码"><a href="#桥接模式示例代码" class="headerlink" title="桥接模式示例代码"></a>桥接模式示例代码</h2><p>先看看Implementor接口的定义，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Abstraction接口的定义，注意一点，虽然说是接口定义，但其实是实现成为抽象类。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Implementor impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该来看看具体的实现了，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看看扩展Abstraction接口的对象实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例操作，实现一定的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现一定的功能，可能会使用具体实现部分的实现方法，</span></span><br><span class="line">        <span class="comment">//但是本方法更大的可能是使用Abstraction中定义的方法，</span></span><br><span class="line">        <span class="comment">//通过组合使用Abstraction中定义的方法来完成更多的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用桥接模式重写示例"><a href="#使用桥接模式重写示例" class="headerlink" title="使用桥接模式重写示例"></a>使用桥接模式重写示例</h2><p>学习了桥接模式的基础知识过后，该来使用桥接模式重写前面的示例了。通过示例，来看看使用桥接模式来实现同样的功能，是否能解决“既能方便的实现功能，又能有很好的扩展性”的问题。<br>要使用桥接模式来重新实现前面的示例，首要任务就是要把抽象部分和实现部分分离出来，分析要实现的功能，抽象部分就是各个消息的类型所对应的功能，而实现部分就是各种发送消息的方式。<br>其次要按照桥接模式的结构，给抽象部分和实现部分分别定义接口，然后分别实现它们就可以了。</p><h3 id="从简单功能开始"><a href="#从简单功能开始" class="headerlink" title="从简单功能开始"></a>从简单功能开始</h3><p>从相对简单的功能开始，先实现普通消息和加急消息的功能，发送方式先实现站内短消息和Email这两种。使用桥接模式来实现这些功能的程序结构如图所示<br><img src="http://image.hanschen.site/master/2019-9-2-12-33-19.png" alt="2019-9-2-12-33-19.png"></p><p>还是看看代码实现，会更清楚一些。先看看消息发送器接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发送器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看抽象部分定义的接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的消息对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MessageSender impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractMessageController(MessageSender impl) &#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，转调实现部分的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        impl.send(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看如何具体的实现发送消息，先看站内短消息的实现吧，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以站内短消息的方式发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderSMS</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Email方式的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以Email的方式发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderEmail</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来该看看如何扩展抽象的消息接口了，先看普通消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了</span></span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看加急消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrgencyMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展自己的新功能：监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><p>看了上面的实现，发现使用桥接模式来实现也不是很困难啊，关键得看是否能解决前面提出的问题，那就来添加还未实现的功能看看，添加对特急消息的处理，同时添加一个使用手机发送消息的方式。该怎么实现呢？<br>很简单，只需要在抽象部分再添加一个特急消息的类，扩展抽象消息就可以把特急消息的处理功能加入到系统中了；对于添加手机发送消息的方式也很简单，在实现部分新增加一个实现类，实现用手机发送消息的方式，也就可以了。<br>这么简单？好像看起来完全没有了前面所提到的问题。的确如此，采用桥接模式来实现过后，抽象部分和实现部分分离开了，可以相互独立的变化，而不会相互影响。因此在抽象部分添加新的消息处理，对发送消息的实现部分是没有影响的；反过来增加发送消息的方式，对消息处理部分也是没有影响的。</p><p>接着看看代码实现，先看看新的特急消息的处理类，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialUrgencyMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpecialUrgencyMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"特急："</span> + message;</span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurry</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行催促的业务，发出催促的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看使用手机短消息的方式发送消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderMobile</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用手机的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试一下功能"><a href="#测试一下功能" class="headerlink" title="测试一下功能"></a>测试一下功能</h3><p>看了上面的实现，可能会感觉得到，使用桥接模式来实现前面的示例过后，添加新的消息处理，或者是新的消息发送方式是如此简单，可是这样实现，好用吗？写个客户端来测试和体会一下，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体的实现对象</span></span><br><span class="line">        MessageSender impl = <span class="keyword">new</span> MessageSenderSMS();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个普通消息对象</span></span><br><span class="line">        AbstractMessageController controller = <span class="keyword">new</span> CommonMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个紧急消息对象</span></span><br><span class="line">        controller = <span class="keyword">new</span> UrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个特急消息对象</span></span><br><span class="line">        controller = <span class="keyword">new</span> SpecialUrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把实现方式切换成手机短消息，然后再实现一遍</span></span><br><span class="line">        impl = <span class="keyword">new</span> MessageSenderMobile();</span><br><span class="line">        controller = <span class="keyword">new</span> CommonMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        controller = <span class="keyword">new</span> UrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        controller = <span class="keyword">new</span> SpecialUrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用站内短消息的方式，发送消息&apos;请喝一杯茶&apos;给小李</span><br><span class="line">使用站内短消息的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李</span><br><span class="line">使用站内短消息的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李</span><br></pre></td></tr></table></figure><p>前面三条是使用的站内短消息，后面三条是使用的手机短消息，正确的实现了预期的功能。看来前面的实现应该是正确的，能够完成功能，且能灵活扩展。</p><h1 id="广义桥接-Java中无处不桥接"><a href="#广义桥接-Java中无处不桥接" class="headerlink" title="广义桥接-Java中无处不桥接"></a>广义桥接-Java中无处不桥接</h1><p>使用Java编写程序，一个很重要的原则就是“面向接口编程”，说得准确点应该是“面向抽象编程”，由于在Java开发中，更多的使用接口而非抽象类，因此通常就说成“面向接口编程”了。接口把具体的实现和使用接口的客户程序分离开来，从而使得具体的实现和使用接口的客户程序可以分别扩展，而不会相互影响。</p><p>桥接模式中的抽象部分持有具体实现部分的接口，最终目的是什么，还不是需要通过调用具体实现部分的接口中的方法，来完成一定的功能，这跟直接使用接口没有什么不同，只是表现形式有点不一样。再说，前面那个使用接口的客户程序也可以持有相应的接口对象，这样从形式上就一样了。</p><p>也就是说，从某个角度来讲，桥接模式不过就是对“面向抽象编程”这个设计原则的扩展。正是通过具体实现的接口，把抽象部分和具体的实现分离开来，抽象部分相当于是使用实现部分接口的客户程序，这样抽象部分和实现部分就松散耦合了，从而可以实现相互独立的变化。</p><p>这样一来，几乎可以把所有面向抽象编写的程序，都视作是桥接模式的体现，至少算是简化的桥接模式，就算是广义的桥接吧。而Java编程很强调“面向抽象编程”，因此，广义的桥接，在Java中可以说是无处不在。</p><h1 id="桥接模式在Android中的应用"><a href="#桥接模式在Android中的应用" class="headerlink" title="桥接模式在Android中的应用"></a>桥接模式在Android中的应用</h1><p>如果各位童鞋看到这里仍然对桥接模式还是不太清楚，在这里给大家举个在Android中非常常用的桥接模式栗子：<code>AbsListView</code>与<code>ListAdapter</code>之间的桥接模式。童鞋们可以根据这个栗子体会一下桥接模式的好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;场景问题&quot;&gt;&lt;a href=&quot;#场景问题&quot; class=&quot;headerlink&quot; title=&quot;场景问题&quot;&gt;&lt;/a&gt;场景问题&lt;/h1&gt;&lt;h2 id=&quot;发送消息&quot;&gt;&lt;a href=&quot;#发送消息&quot; class=&quot;headerlink&quot; title=&quot;发送消息&quot;&gt;&lt;/a&gt;发送消息&lt;/h2&gt;&lt;p&gt;现在我们要实现这样一个功能：发送消息。从业务上看，消息又分成普通消息、加急消息和特急消息多种，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加“加急”字样，而特急消息除了添加特急外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内短消息、手机短消息、邮件等等。现在要实现这样的发送提示消息的功能，该如何实现呢？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="http://blog.hanschen.site/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="http://blog.hanschen.site/2016/12/27/pattern_proxy/"/>
    <id>http://blog.hanschen.site/2016/12/27/pattern_proxy/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们执行一个功能的函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码，如日志记录、信息发送、安全和事务支持等，这些<code>枝节性代码</code>虽然是必要的，但它会带来以下麻烦：</p><ul><li>枝节性代码游离在功能性代码之外，它下是函数的目的</li><li>枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合</li><li>枝节性代码带来的耦合度会造成功能性代码移植困难，可重用性降低</li></ul><p>毫无疑问，枝节性代码和功能性代码需要分开来才能降低耦合程度，我们可以使用<strong>代理模式(委托模式)</strong>完成这个要求。代理模式的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p><p>代理模式一般涉及到三个角色：</p><ul><li><strong>抽象角色</strong>：声明真实对象和代理对象的共同接口</li><li><strong>代理角色</strong>：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象 与真实对象有相同的接口，能在任何时候代替真实对象，代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展。</li><li><strong>真实角色</strong>：代理角色所代表的真实对象，是我们最终要引用的对象</li></ul><p>常见的代理应用场景有：</p><ul><li><strong>远程代理</strong>：对一个位于不同的地址空间对象提供一个局域代表对象，如RMI中的stub</li><li><strong>虚拟代理</strong>：根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建</li><li><strong>保护代理</strong>：控制对一个对象的访问权限</li><li><strong>智能引用</strong>：提供比目标对象额外的服务和功能</li></ul><p>接下来，我们用代码来说明什么是代理模式</p><a id="more"></a><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>先看看代理模式的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-12-29-26.png" alt="2019-9-2-12-29-26.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面给出一个小栗子说明代理模式，先定义一个抽象角色，也就是一个公共接口，声明一些需要代理的方法,本文定义一个<code>Subject</code>接口，为了简单说明，只是在里面定义一个request方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Subject的实现类<code>RealSubject</code>，它是一个真实角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"do real request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个代理角色<code>ProxySubject</code>，跟RealSubject一样，它也继承了Subject接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"before"</span>);</span><br><span class="line">        mSubject.request();</span><br><span class="line">        System.out.print(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简易的代理模式模型就建立了，客户端在使用过程中，无需关注RealSubject，只需要关注ProxySubject就行了，并且可以在ProxySubject中插入一些非功能信的代码，比如输出Log，统计执行时间等等</p><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><p>远程代理，对一个位于不同的地址空间对象提供一个局域代表对象。这样说大家可能比较抽象，不太能理解，但其实童鞋们可能在就接触过了，在Android中，Binder的使用就是典型的远程代理。比如ActivityManager：<br><img src="http://image.hanschen.site/master/2019-9-2-12-29-57.png" alt="2019-9-2-12-29-57.png"></p><p>在启动Activity的时，会调用<code>ActivityManager</code>的startActivity方法，我们看看Activity是怎么获取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">        (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回代理类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终是返回了一个ActivityManager的代理类，因为真正的ActivityManager是运行在内核空间的，Android应用无法直接访问得到，那么就可以借助这个ActivityManagerProxy，通过Binder与真正的ActivityManager，也就是<code>ActivityManagerService</code>交互。其中ActivityManagerService和ActivityManagerProxy都实现了同一个接口：<code>IActivityManager</code>。这个就是Android中典型的代理模式的栗子了。至于ActivityManagerService和ActivityManagerProxy是如何通过Binder实现远程调用，这个就是另一个话题Binder的内容了，这里不再做阐述</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建。假设我们创建RealSubject需要耗费一定的资源，那么，我们可以把创建它延迟到实际调用的时候，优化Client初始化速度，比如，这样修改ProxySubject以达到延迟加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延时加载</span></span><br><span class="line">        <span class="keyword">if</span> (mSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        mSubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client在实例化ProxySubject的时候，不需消耗资源，而是等到真正调用request的时候，才会加载RealSubject，达到延时加载的效果</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>可以在Proxy类中加入进行权限，验证是否具有执行真实代码的权限，只有权限验证通过了才进行真实对象的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line">    <span class="keyword">private</span> User        mUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUser = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证权限</span></span><br><span class="line">        <span class="keyword">if</span> (mUser.isLogin()) &#123;</span><br><span class="line">            mSubject.request();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a>额外功能</h2><p>通过引入代理类，可以方便地在功能性代码前后插入扩展，如Log输出，调用统计等，实现对原代码的<strong>无侵入</strong>式代码扩展，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Log: before"</span>);</span><br><span class="line">        mSubject.request();</span><br><span class="line">        System.out.print(<span class="string">"Log: after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h1><p>静态代理和动态代理的概念和使用可以参考我另一篇文章：<a href="http://blog.csdn.net/shensky711/article/details/52872249" target="_blank" rel="noopener">Java动态代理：http://blog.csdn.net/shensky711/article/details/52872249</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;我们执行一个功能的函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码，如日志记录、信息发送、安全和事务支持等，这些&lt;code&gt;枝节性代码&lt;/code&gt;虽然是必要的，但它会带来以下麻烦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;枝节性代码游离在功能性代码之外，它下是函数的目的&lt;/li&gt;
&lt;li&gt;枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合&lt;/li&gt;
&lt;li&gt;枝节性代码带来的耦合度会造成功能性代码移植困难，可重用性降低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;毫无疑问，枝节性代码和功能性代码需要分开来才能降低耦合程度，我们可以使用&lt;strong&gt;代理模式(委托模式)&lt;/strong&gt;完成这个要求。代理模式的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。&lt;/p&gt;
&lt;p&gt;代理模式一般涉及到三个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象角色&lt;/strong&gt;：声明真实对象和代理对象的共同接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理角色&lt;/strong&gt;：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象 与真实对象有相同的接口，能在任何时候代替真实对象，代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真实角色&lt;/strong&gt;：代理角色所代表的真实对象，是我们最终要引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的代理应用场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;远程代理&lt;/strong&gt;：对一个位于不同的地址空间对象提供一个局域代表对象，如RMI中的stub&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟代理&lt;/strong&gt;：根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保护代理&lt;/strong&gt;：控制对一个对象的访问权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;智能引用&lt;/strong&gt;：提供比目标对象额外的服务和功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们用代码来说明什么是代理模式&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://blog.hanschen.site/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入利器 - Dagger ‡</title>
    <link href="http://blog.hanschen.site/2016/12/18/dagger2/"/>
    <id>http://blog.hanschen.site/2016/12/18/dagger2/</id>
    <published>2016-12-17T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在开发过程中，为了实现解耦，我们经常使用依赖注入，常见的依赖注入方式有：</p><ul><li><strong>构造方法注入</strong>：在构造方法中把依赖作为参数传递进去</li><li><strong>setter方法注入</strong>：添加setter方法，把依赖传递进去</li><li><strong>接口注入</strong>：把注入方法抽到一个接口中，然后实现该接口，把依赖传递进去</li></ul><p>下面用一个小栗子来说明三种方式的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">DependencyInjecter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonDao</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口注入：实现DependencyInjecter接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectPersonDao</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a id="more"></a><p>我们来看下使用一般的依赖注入方法时，代码会是怎么样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建PersonService的依赖：personDao</span></span><br><span class="line">        PersonDao personDao = <span class="keyword">new</span> PersonDaoImpl();</span><br><span class="line">        <span class="comment">// 通过构造方法注入依赖</span></span><br><span class="line">        mService = <span class="keyword">new</span> PersonService(personDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还好是吧？但现实情况下，依赖情况往往是比较复杂的，比如很可能我们的依赖关系如下图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-38-41.png" alt="2019-9-2-11-38-41.png"></p><p>PersonDaoImpl依赖类A，类A依赖B，B依赖C和D…在这种情况下，我们就要写出下面这样的代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建依赖D</span></span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        <span class="comment">// 创建依赖C</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        <span class="comment">// 创建依赖B</span></span><br><span class="line">        B b = <span class="keyword">new</span> B(c, d);</span><br><span class="line">        <span class="comment">// 创建依赖A</span></span><br><span class="line">        A a = <span class="keyword">new</span> A(b);</span><br><span class="line">        <span class="comment">// 创建PersonService的依赖：personDao</span></span><br><span class="line">        PersonDao personDao = <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">        <span class="comment">// 通过构造方法注入依赖</span></span><br><span class="line">        mService = <span class="keyword">new</span> PersonService(personDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity只是想使用PersonService而已，却不得不关注PersonService的依赖是什么、PersonDaoImpl依赖的依赖是什么，需要把整个依赖关系搞清楚才能使用PersonService。而且还有一个不好的地方，一旦依赖关系变更了，比如A不再依赖B了，那么就得修改所有创建A的地方。那么，有没有更好的方式呢？Dagger就是为此而生的，让我们看看使用Dagger后，MainActivity会变成什么模样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dagger注入，读者现在可先不关注里面做了什么操作</span></span><br><span class="line">        DaggerPersonServiceComponent.create().inject(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，mService已经是非空了，可以正常使用</span></span><br><span class="line">        mService.update(<span class="number">1</span>, <span class="string">"HansChen"</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前创建A、B、C、D、PersonDaoImpl等依赖的代码全不见了，只需要调用一个注入语句就全搞定了。调用了注入语句之后，mService就可以正常使用了，是不是挺方便呢？至于这句注入语句具体干了什么，读者现在可以先不管，后面会有详细说明，这里只是做一个使用演示而已。</p><p>我们大概猜想一下，在MainActivity使用PersonService需要做哪些？</p><ol><li>分析生成依赖关系图，如PersonService–&gt;PersonDaoImpl–&gt;A–&gt;B–&gt;C&amp;D</li><li>根据依赖关系图获取相关依赖，比如依次创建D、C、B、A、PersonDaoImpl、PersonService的实例</li><li>把生成的PersonService实例传递给MainActivity的mService成员变量</li></ol><p>其实Dagger做的也就是上面这些事情了，接下来就让我们真正开始学习Dagger吧</p><h1 id="声明需要注入的对象"><a href="#声明需要注入的对象" class="headerlink" title="声明需要注入的对象"></a>声明需要注入的对象</h1><p>首先我们应该用<code>javax.inject.Inject</code>去注解需要被自动注入的对象，@Inject是Java标准的依赖注入（JSR-330）注解。比如下面栗子中，需要注入的对象就是MainActivity的mService。这里有个要注意的地方，<strong>被@Inject注解的变量不能用private修饰</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，不能被private修饰</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实例化出依赖？"><a href="#如何实例化出依赖？" class="headerlink" title="如何实例化出依赖？"></a>如何实例化出依赖？</h1><p>在执行依赖注入的时候，Dagger会查找@Inject注解的成员变量，并尝试获取该类的实例，Dagger最直接的方式就是直接new出相应的对象了。实例化对象的时候，会调用对象的构造方法，但假如有多个构造方法，具体用哪个构造方法来实例化对象？Dagger肯定是不会帮我们“擅自做主”的，用哪个构造方法来实例化对象应该是由我们做主的，所以我们需要<strong>给相应的构造方法添加@Inject注解</strong>。<br>当Dagger需要实例化该对象的时候，会调用@Inject注解的构造方法来实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">DependencyInjecter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用@Inject注解，相当于告诉Dagger需要实例化PersonService的时候，请调用这个构造方法</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明的你应该发现了，调用PersonService的构造方法需要传入PersonDao实例，所以要实例化PersonService，必须先要实例化PersonDao，Dagger会帮我们自动分析出这个依赖关系，并把它添加到<strong>依赖关系图</strong>里面！Dagger会尝试先去实例化一个PersonDao,如果PersonDao又依赖于另外一个对象A，那么就先尝试去实例化A……以此类推，是不是很像递归？当所有依赖都被实例化出来之后，我们的PersonService当然也被构造出来了。</p><p>问题又来了，如果PersonDao是一个接口呢？Dagger怎么知道这个接口应该怎么实现？答案是不知道的，那么Dagger怎么实例化出一个接口出来？这个就是Module存在的意义之一了。关于Module的讲解我们会在后面详细说明，我们现在只要知道，Module里面会定义一些方法，这些方法会返回我们的依赖，就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供PersonDao接口实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">PersonDao <span class="title">providePersonDao</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dagger根据需求获取一个实例的时候，并不总是通过new出来的，它会<strong>优先</strong>查找Module<br>中是否有返回相应实例的方法，如果有，就调用Module的方法来获取实例。</p><p>比如你用@Inject注解了一个成员变量，Dagger会查找Module中是否有用@Provides注解的，返回该类实例的方法，有的话就会调用provide方法来获得实例，然后注入，如果没有的话Dagger就会尝试new出一个实例。就像我们现在这个栗子，PersonService依赖于PersonDao接口，Dagger不能直接为我们new出一个接口，但我们可以提供一个Module，在Module中定义一个返回PersonDao接口实例的方法，这样，Dagger就可以解决实例化PersonDao的问题了。</p><p>我们再梳理一下流程，如果我们用@Inject注解了一个成员变量，并调用注入代码之后，Dagger会这样处理：</p><ol><li>查找Module中是否有用@Provides注解的，返回该类实例的方法</li><li>如果有，就调用那个provide方法来获得实例，然后注入</li><li>如果没有，就尝试调用相应的类中被@Inject注解的构造方法new出一个实例，然后注入</li><li>如果没有一个构造方法被@Inject注解，Dagger会因不能满足依赖而出错</li></ol><p>所以假如一个变量被@Inject注解，要么在Module中提供provide方法获取实例，要么该类提供一个被@Inject注解的构造方法，否则Dagger会出错</p><h1 id="Module的使用"><a href="#Module的使用" class="headerlink" title="Module的使用"></a>Module的使用</h1><p>一般而言，Dagger会获取所有依赖的实例，比如当需要一个<code>TestBean</code>的时候，会通过<code>new TestBean()</code>创建实例并注入到类中。但是，以下情况会就不好处理了：</p><ol><li>需要生成的是一个接口，而Dagger不能直接实例化接口</li><li>不能在第三方库的类中添加注解</li><li>可配置的对象必须是配置的</li></ol><p>为了解决以上问题，我们需要定义一个被@Module注解的类，在里面定义用<code>@Provides</code>注解的方法。用该方法返回所需的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">D <span class="title">provideD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> D();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">C <span class="title">provideC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">B <span class="title">provideB</span><span class="params">(C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B(c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">A <span class="title">provideA</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供PersonDao实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">PersonDao <span class="title">providePersonDao</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像<code>providePersonDao</code>返回了PersonDao接口实例，Dagger虽然不能直接实例化出PersonDao接口，但却可以调用Module的providePersonDao方法来获得一个实例。providePersonDao方法需要传入A的实例，那么这里也构成了一个依赖关系图。Dagger会先获取A的实例，然后把实例传递给providePersonDao方法。</p><h1 id="Component的使用"><a href="#Component的使用" class="headerlink" title="Component的使用"></a>Component的使用</h1><p>到目前为止，我们虽然知道了：</p><ul><li>Dagger怎么获取实例：<ul><li>从Module的provide方法中获取</li><li>通过@Inject注解的构造方法new出新的实例</li></ul></li><li>Dagger会推导provide方法和构造方法的参数，形成依赖图，并“满足”我们依赖图的需求，获取依赖的实例</li></ul><p>看样子需要注入的依赖可以获取了，但是不是总觉得还有点“零碎”，整个流程还没连贯起来？比如，Module既然是一个类，生成依赖图的时候，怎么知道跟哪个Module挂钩？即使最后生成了需要的实例，注入的“目的地”是哪里？怎么才能把它注入到“目的地”？残缺的这部分功能，正是Component提供的，Component起到了一个桥梁的作用，贯通Module和注入目标。我们来看看最开始那个例子，我们是怎么进行依赖注入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        PersonServiceComponent component = DaggerPersonServiceComponent.builder()</span><br><span class="line">                                                                       .personServiceModule(<span class="keyword">new</span> PersonServiceModule())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        <span class="comment">// 注入,所有@Inject注解的成员变量都会同时注入</span></span><br><span class="line">        component.inject(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过component获取实例，注意，这里只是演示用法，其实mService在component.inject的时候已经完成了注入</span></span><br><span class="line">        mService = component.getPersonService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个DaggerPersonServiceComponent是什么鬼？DaggerPersonServiceComponent其实是Dagger为我们<strong>自动生成</strong>的类，它实现了一个Component接口（这个接口是需要我们自己写的），我们来看下它实现的接口长什么样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定PersonServiceModule，当需要获取某实例的时候，会查找PersonServiceModule中是否有返回相应类型的方法，有的话就通过该方法获得实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(modules = PersonServiceModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonServiceComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找activity中被<span class="doctag">@Inject</span>注解的成员变量，并尝试获取相应的实例，把实例赋给activity的成员变量</span></span><br><span class="line"><span class="comment">     * 注意函数格式:返回值为空、带有一个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dagger会尝试从Module中获取PersonService实例，如果Module中不能获取对应实例，则通过PersonService的构造方法new出一个实例</span></span><br><span class="line"><span class="comment">     * 注意函数格式：参数为空，返回值非空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PersonService <span class="title">getPersonService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口被Component注解修饰，它里面可以定义3种类型的方法：</p><ul><li>返回值为空，有一个参数：查找参数中被@Inject注解的成员变量，并尝试获取相应的实例（通过Module的provide方法或@Inject注解的构造方法new出新的实例），把实例赋给参数的成员变量</li><li>返回值非空，参数为空：获取相应实例并返回</li><li>返回值是Component，参数是Moduld，通过该方法可以创建SubComponent实例</li></ul><p>既然获取实例的时候，有可能用到Module，那么就必须为这个Component指定使用的Module是什么。具体做法就是在@Component注解中指定modules。<br>定义好Component之后，Dagger会自动帮我们生成实现类，这就是Dagger强大的地方！生成的类名格式是：Dagger+Component名。<br>Component提供了2种方法，一个是注入式方法，一个是获取实例方法。具体用什么方法，就看个人需求了。<strong>一个Component其实也对应了一个依赖图</strong>，因为Component使用哪个Module是确定不变的，依赖关系无非也就是跟Module和类的定义有关。一旦这些都确定下来了，在这个Component范围内，依赖关系也就被确定下来了。额外再说一点，在Dagger1中，Component的功能是由<code>ObjectGraph</code>实现的，Component是用来代替它的。</p><p>Component定义好之后，build一下工程，Dagger就会自动为我们生成实现类了，就可以使用自动生成的实现类来进行依赖注入了。到现在为止，我们已经通过Dagger完成了依赖注入。可能看起来比正常方法麻烦得多，但是Dagger框架可以让依赖的注入和配置独立于组件之外，它帮助你专注在那些重要的功能类上。通过声明依赖关系和指定规则构建整个应用程序。</p><p>熟悉完Dagger基本的使用之后，接下来我们来讲解一些稍微高级一点的用法：</p><h1 id="Dagger的进阶使用"><a href="#Dagger的进阶使用" class="headerlink" title="Dagger的进阶使用"></a>Dagger的进阶使用</h1><h2 id="Components之间的关系"><a href="#Components之间的关系" class="headerlink" title="Components之间的关系"></a>Components之间的关系</h2><p>在Dagger中，Component之间可以有两种关系:Subcomponents和Component dependencies。他们有什么作用呢？比如在我们应用中，经常会有一些依赖我们在各个界面都使用得到，比如操作数据库、比如网络请求。假设我们有个ServerApi的接口，在页面A、B、C都使用到了，那么我们要在页面A、B、C的Component里面都能获取到ServerApi的实例，但显然，获取ServerApi实例的方法都是一样的，我们不想写重复的代码。于是我们可定义一个ApplicationComponent，在里面返回ServerApi实例，通过Component之间的关系便可以共享ApplicationComponent提供的依赖图。</p><p>下面通过Android中的一个小栗子来说明Subcomponents和Component dependencies如何使用</p><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>先说明下各个模块之间的关系<br>首先，我们定义一个ApplicationComponent，它定义了一个方法，通过它来获得ServerApi实例。ApplicationComponent还关联了ApplicationModule，这个Module是ServerApi实例的提供者，注意，这个Moduld还可以返回Context实例<br><img src="http://image.hanschen.site/master/2019-9-2-11-41-18.png" alt="2019-9-2-11-41-18.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServerApi <span class="title">getServerApi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mAppContext;</span><br><span class="line"></span><br><span class="line">    ApplicationModule(Context context) &#123;</span><br><span class="line">        mAppContext = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Context <span class="title">provideAppContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAppContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApi</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImpl(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationComponent mAppComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mAppComponent = DaggerApplicationComponent.builder().applicationModule(<span class="keyword">new</span> ApplicationModule(<span class="keyword">this</span>)).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationComponent <span class="title">getAppComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAppComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity使用MVP模式，在MainPresenter里面需要传入一个ServerApi对象<br><img src="http://image.hanschen.site/master/2019-9-2-11-43-13.png" alt="2019-9-2-11-43-13.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这里有个dependencies声明</span></span><br><span class="line"><span class="meta">@Component</span>(dependencies = ApplicationComponent.class, modules = MainPresenterModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainPresenterComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenter <span class="title">getMainPresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenterModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView mMainView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenterModule</span><span class="params">(MainView mainView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">MainView <span class="title">provideMainView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMainView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView  mMainView;</span><br><span class="line">    <span class="keyword">private</span> ServerApi mServerApi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">(MainView mainView, ServerApi serverApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">        <span class="keyword">this</span>.mServerApi = serverApi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先抛开dependencies，我们分析这个这个依赖树是怎么样的<br><img src="http://image.hanschen.site/master/2019-9-2-11-43-43.png" alt="2019-9-2-11-43-43.png"><br>Component中getMainPresenter的目的很简单，就是返回MainPresenter，而MainPresenter又依赖MainView和ServerApi，MainView还好说，在MainPresenterModule中有provide方法，但是ServerApi呢？就像上面说的那样，如果我们在这个Moduld中也添加相应的provide方法，那真是太麻烦了（当然，这样做完全是可以实现的），所以我们依赖了ApplicationComponent，通过dependencies，在被依赖的Component暴露的对象，在子Component中是可见的。这个是什么意思呢？意思有两个：</p><ol><li>被依赖Component接口暴露的对象，可以添加到依赖者的依赖图中</li><li>Component接口没有暴露的对象，依赖者是不可见的</li></ol><p>对于第一点应该比较好理解，就像这个栗子，MainPresenterComponent生成MainPresenter需要ServerApi，而ApplicationComponent中有接口暴露了ServerApi，所以MainPresenterComponent可以获得ServerApi<br>对于第二点，假设MainPresenter还需要传入一个Context对象，我们注意到，ApplicationModule是可以提供Context的，那MainPresenterComponent能不能通过ApplicationComponent获取Context实例？答案是不行的，因为ApplicationComponent没有暴露这个对象。想要获取Context，除非ApplicationComponent中再添加一个getContext的方法。</p><p>他们之间的关系可以用下图描述：<br><img src="http://image.hanschen.site/master/2019-9-2-11-44-12.png" alt="2019-9-2-11-44-12.png"></p><h3 id="Subcomponents"><a href="#Subcomponents" class="headerlink" title="Subcomponents"></a>Subcomponents</h3><p>Subcomponents 实现方法一：</p><ul><li>先定义子 Component，使 用@Subcomponent 标注（不可同时再使用 @Component）</li><li>父 Component 中定义获得子 Component 的方法</li></ul><p>让我们对上面的栗子改造改造：<br>去除MainPresenterComponent的Component注解，改为Subcomponent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span>(modules = MainPresenterModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainPresenterComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenter <span class="title">getMainPresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ApplicationComponent中新增plus方法（名字可随意取），返回值为MainPresenterComponent，参数为MainPresenterModule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenterComponent <span class="title">plus</span><span class="params">(MainPresenterModule <span class="keyword">module</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就构建了一个ApplicationComponent的子图：MainPresenterComponent。子图和dependencies的区别就是，子图可以范围父图所有的依赖，也就是说，子图需要的依赖，不再需要在父Component中暴露任何对象，可以直接通过父图的Moduld提供！他们的关系变为了：<br><img src="http://image.hanschen.site/master/2019-9-2-11-44-34.png" alt="2019-9-2-11-44-34.png"></p><p>这里需要注意的是，以上代码直接在父 Component 返回子 Component 的形式，要求子 Component 依赖的 Module 必须包含一个无参构造函数，用以自动实例化。如果 Module 需要传递参数，则需要使用 <code>@Subcomponent.builder</code> 的方式，实现方法二实现步骤如下：</p><ul><li>在子 Component，定义一个接口或抽象类（通常定义为 Builder），使用 @Subcomponent.Builder 标注<ul><li>编写返回值为 Builder，方法的参数为需要传入参数的 Module</li><li>编写返回值为当前子 Component的 无参方法</li></ul></li><li>父 Component 中定义获得子 Component.Builder 的方法</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestModule</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">AuthManager <span class="title">provideAuthManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AuthManager.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = &#123;TestModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AuthManager <span class="title">getAuthManager</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Builder <span class="title">createBuilder</span><span class="params">(TestModule <span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">TestComponent <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    TestComponent.<span class="function">Builder <span class="title">testComponentBuilder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">TestComponent testComponent = mApplicationComponent.testComponentBuilder().createBuilder(<span class="keyword">new</span> TestModule(<span class="string">"test"</span>)).build();</span><br></pre></td></tr></table></figure><h2 id="Binds注解"><a href="#Binds注解" class="headerlink" title="Binds注解"></a>Binds注解</h2><p>在Dagger2中，一般都是使用@provide方法注入接口。在Android 中，一般我们会这样做，创建一个接口 Presenter 命名 为 HomePresenter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line">   Observable&lt;List&lt;User&gt;&gt; loadUsers()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个这个接口的实例：HomePresenterImp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePresenterImp</span> <span class="keyword">implements</span> <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomePresenterImp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;List&lt;User&gt;&gt; loadUsers()&#123;</span><br><span class="line">        <span class="comment">//Return user list observable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Module 中，提供实例化的 provide 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HomePresenter <span class="title">providesHomePresenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HomePresenterImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们需要添加一个依赖到 presenter 叫 UserService，那就意味着，我们也要在 module 中添加一个 provide 方法提供这个 UserService，然后在 HomePresenterImp 类中加入一个 UserService 参数的构造方法。<br>有没有觉得这种方法很麻烦呢？我们还可以用 @Binds 注解，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变为 abstract 方法， 同时 Module 也必须声明为 abstract， 传入的参数必须为返回参数的实现类</span></span><br><span class="line">    <span class="comment">// 当需要 HomePresenter 时，dagger 会自动实例化 HomePresenterImp 并返回</span></span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> HomePresenter <span class="title">bindHomePresenter</span><span class="params">(HomePresenterImp homePresenterImp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了方便，使用 @Binds 注解还可以让 dagger2 生成的代码效率更高。但是需要注意的是，由于 Module 变为抽象类，Module 不能再包含非 static 的带 @Provides 注解的方法。而且这时候，依赖此 Module 的 Component 也不需要传入此 Module 实例了（也实例化不了，因为它是抽象的）。相当于此 Module 仅仅作为描述依赖关系的一个类</p><h2 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h2><p>Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。@Singleton是被Dagger预先定义的作用域注解。</p><ul><li>没有指定作用域的@Provides方法将会在每次注入的时候都创建新的对象</li><li>一个没有scope的component不可以依赖一个有scope的组件component</li><li>子组件和父组件的scope不能相同</li><li>Module中provide方法的scope需要与Component的scope一致</li></ul><p>我们通常的ApplicationComponent都会使用Singleton注解，也就会是说我们如果自定义component必须有自己的scope。读者到这里，可能还不能理解Scopes的作用，我们先来看下默认提供的Singlton到底有什么作用，然后再讨论Scopes的意义：</p><h2 id="Singlton"><a href="#Singlton" class="headerlink" title="Singlton"></a>Singlton</h2><p>Singletons是java提供的一个scope，我们来看看Singletons能做什么事情。<br>为@Provides注释的方法或可注入的类添加添加注解@Singlton，构建的这个对象图表将使用唯一的对象实例，比如我们有个ServerApi<br>方法一：用@Singleton注解类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HansChen"</span>.equals(username) &amp;&amp; <span class="string">"123456"</span>.equals(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：用@Singleton注解Module的provide方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们有个Component：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServerApi <span class="title">getServerApi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行依赖注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ServerApi mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ApplicationComponent component = DaggerApplicationComponent.create();</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了以上两种方法的任意一种，我们都会发现，通过component.getServerApi()获得的实例都是同一个实例。不过要注意一点的是，如果类用@Singleton注解了，但Module中又存在一个provide方法是提供该类实例的，但provide方法没有用@Singleton注解，那么Component中获取该实例就不是单例的，因为会优先查找Module的方法。<br>这个单例是相对于同一个Component而言的，不同的Component获取到的实例将会是不一样的。</p><h2 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h2><p>既然一个没有scope的component不可以依赖一个有scope的组件component，那么我们必然需要自定义scope来去注解自己的Component了，定义方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FragmentScoped &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义出来的FragmentScoped在使用上和Singleton是一样的，那它和Singleton除了是不一样的注解之外，还有什么不一样呢？答案是没有！我们自定义的scope和Singleton并没有任何不一样，不会因为Singleton是java自带的注解就会有什么区别。</p><p>那么，这个scope的设定是为了什么呢？</p><h2 id="scope的作用"><a href="#scope的作用" class="headerlink" title="scope的作用"></a>scope的作用</h2><p>scope除了修饰provide方法可以让我们获得在同一个Component实例范围内的单例之外，主要的作用就是对Component和Moduld的分层管理以及依赖逻辑的可读性。<br>这里借用一个网络上的图片说明：<br><img src="http://image.hanschen.site/master/2019-9-2-11-44-58.png" alt="2019-9-2-11-44-58.png"></p><p>ApplicationComponent一般会用singleton注解，相对的，它的Module中provide方法也只能用singleton注解。UserComponent是用UserSCope能直接使用ApplicationModule吗？不能！因为他俩的scope不一致，这就是这个设定带来的好处，防止不同层级的组件混乱。另外，因为有了scope的存在，各种组件的作用和生命周期也变得可读起来了</p><h2 id="Lazy注入"><a href="#Lazy注入" class="headerlink" title="Lazy注入"></a>Lazy注入</h2><p>有时可能会需要延迟获取一个实例。对任何绑定的 T，可以构建一个 Lazy<t> 来延迟实例化直至第一次调用 Lazy<t> 的 get() 方法。注入之后，第一次get的时会实例化出 T，之后的调用都会获取相同的实例。</t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">MainView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒加载</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Lazy&lt;MainPresenter&gt; mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainPresenterComponent component = DaggerMainPresenterComponent.builder()</span><br><span class="line">                                                                       .mainPresenterModule(<span class="keyword">new</span> MainPresenterModule(<span class="keyword">this</span>))</span><br><span class="line">                                                                       .applicationComponent(((DemoApplication) getApplication()).getAppComponent())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 实例化MainPresenter</span></span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 跟上次获取的实例是同一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Provider注入"><a href="#Provider注入" class="headerlink" title="Provider注入"></a>Provider注入</h2><p>跟Lazy注入不一样的是，有时候我们希望每次调用get的时候，获取到的实例都是不一样的，这时候可以用Provider注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">MainView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provider</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Provider&lt;MainPresenter&gt; mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainPresenterComponent component = DaggerMainPresenterComponent.builder()</span><br><span class="line">                                                                       .mainPresenterModule(<span class="keyword">new</span> MainPresenterModule(<span class="keyword">this</span>))</span><br><span class="line">                                                                       .applicationComponent(((DemoApplication) getApplication()).getAppComponent())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 实例化MainPresenter</span></span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 获取新的MainPresenter实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qualifiers注入"><a href="#Qualifiers注入" class="headerlink" title="Qualifiers注入"></a>Qualifiers注入</h2><p>到目前为止，我们的demo里，Moduld的provide返回的对象都是不一样的,但是下面这种情况就不好处理了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回ServerApi实例</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiA</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplA(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ServerApi实例</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiB</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplB(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provideServerApiA和provideServerApiB返回的都是ServerApi，Dagger是无法判断用哪个provide方法的。这时候就需要添加Qualifiers了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">"ServerApiImplA"</span>)</span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiA</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplA(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">"ServerApiImplB"</span>)</span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiB</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplB(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样一个限定，就能区分出2个方法的区别了，当然，在使用过程中，也同样要指明你用哪个name的实例,Dagger会根据你的name来选取对应的provide方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView  mMainView;</span><br><span class="line">    <span class="keyword">private</span> ServerApi mServerApi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">(MainView mainView, @Named(<span class="string">"ServerApiImplA"</span>)</span> ServerApi serverApi) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">        <span class="keyword">this</span>.mServerApi = serverApi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了用Named注解，你也可以创建你自己的限定注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YourQualifier &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译时验证"><a href="#编译时验证" class="headerlink" title="编译时验证"></a>编译时验证</h2><p>Dagger 包含了一个注解处理器（annotation processor）来验证模块和注入。这个过程很严格而且会抛出错误，当有非法绑定或绑定不成功时。下面这个例子缺少了 Executor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span> <span class="function">Heater <span class="title">provideHeater</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuHeater(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，javac 会拒绝绑定缺少的部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] COMPILATION ERROR :</span><br><span class="line">[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.</span><br></pre></td></tr></table></figure><p>可以通过给方法 Executor 添加@Provides注解来解决这个问题，或者标记这个模块是不完整的。不完整的模块允许缺少依赖关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span>(complete = <span class="keyword">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span> <span class="function">Heater <span class="title">provideHeater</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuHeater(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第一次接触用Dagger框架写的代码时候，如果不了解各种注解作用的时候，那真会有一脸懵逼的感觉，而且单看文章，其实还是很抽象，建议大家用Dagger写个小demo玩玩，很快就上手了，这里提供几个使用Dagger的栗子，希望可以帮助大家上手Dagger</p><ul><li><a href="https://github.com/google/dagger/tree/master/examples" target="_blank" rel="noopener">Dagger demo</a></li><li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-dagger" target="_blank" rel="noopener">谷歌官方 MVP+Dagger2 Demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在开发过程中，为了实现解耦，我们经常使用依赖注入，常见的依赖注入方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;：在构造方法中把依赖作为参数传递进去&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setter方法注入&lt;/strong&gt;：添加setter方法，把依赖传递进去&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口注入&lt;/strong&gt;：把注入方法抽到一个接口中，然后实现该接口，把依赖传递进去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面用一个小栗子来说明三种方式的用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DependencyInjecter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; PersonDao personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造方法注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonService&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// setter方法注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPersonDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 接口注入：实现DependencyInjecter接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;injectPersonDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ... ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.hanschen.site/categories/Java/"/>
    
    
      <category term="依赖注入" scheme="http://blog.hanschen.site/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Dagger" scheme="http://blog.hanschen.site/tags/Dagger/"/>
    
  </entry>
  
  <entry>
    <title>Robolectric使用教程</title>
    <link href="http://blog.hanschen.site/2016/12/10/robolectric/"/>
    <id>http://blog.hanschen.site/2016/12/10/robolectric/</id>
    <published>2016-12-09T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android的单元测试可以分为两部分：</p><ol><li>Local unit tests：运行于本地JVM</li><li>Instrumented test：运行于真机或者模拟器</li></ol><p>如果使用Local测试，需要保证测试过程中不会调用Android系统API，否则会抛出RuntimeException异常，因为Local测试是直接跑在本机JVM的，而之所以我们能使用Android系统API，是因为编译的时候，我们依赖了一个名为“android.jar”的jar包，但是jar包里所有方法都是直接抛出了一个RuntimeException，是没有任何任何实现的，这只是Android为了我们能通过编译提供的一个Stub！当APP运行在真实的Android系统的时候，由于类加载机制，会加载位于framework的具有真正实现的类。由于我们的Local是直接在PC上运行的，所以调用这些系统API便会出错。<br>那么问题来了，我们既要使用Local测试，但测试过程又难免遇到调用系统API那怎么办？其中一个方法就是mock objects，比如借助Mockito，另外一种方式就是使用<code>Robolectric</code>， Robolectric就是为解决这个问题而生的。它实现一套JVM能运行的Android代码，然后在unit test运行的时候去截取android相关的代码调用，然后转到他们的他们实现的Shadow代码去执行这个调用的过程</p><a id="more"></a><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><h2 id="为项目添加依赖"><a href="#为项目添加依赖" class="headerlink" title="为项目添加依赖"></a>为项目添加依赖</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile <span class="string">"org.robolectric:robolectric:3.1.4"</span></span><br></pre></td></tr></table></figure><p>Robolectric在第一次运行时，会下载一些sdk依赖包，每个sdk依赖包大概50M，下载速度比较慢，用户可以直接在网上下载相应依赖包，放置在本地maven仓库地址中，默认路径为：<code>C:\Users\username\.m2\repository\org\robolectric</code></p><h2 id="指定RobolectricTestRunner为运行器"><a href="#指定RobolectricTestRunner为运行器" class="headerlink" title="指定RobolectricTestRunner为运行器"></a>指定RobolectricTestRunner为运行器</h2><p>为测试用例添加注解,指定测试运行器为RobolectricTestRunner。注意，这里要通过Config指定<code>constants = BuildConfig.class</code>，Robolectric 会通过constants推导出输出路径，如果不进行配置，Robolectric可能不能找到你的manifest、resources和assets资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是Shadow类"><a href="#什么是Shadow类" class="headerlink" title="什么是Shadow类"></a>什么是Shadow类</h2><p>Shadow是Robolectric的立足之本，如其名，作为影子，一定是变幻莫测，时有时无，且依存于本尊。Robolectric定义了大量模拟Android系统类行为的Shadow类，当这些系统类被创建的时候，Robolectric会查找对应的Shadow类并创建一个Shadow类与原始类关联。每当系统类的方法被调用的时候，Robolectric会保证Shadow对应的方法会调用。这些Shadow对象，丰富了本尊的行为，能更方便的对Android相关的对象进行测试。<br>比如，我们可以借助ShadowActivity验证页面是否正确跳转了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJump</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume</span></span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    <span class="comment">// 触发按钮点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_jump).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的Shadow类</span></span><br><span class="line">    ShadowActivity shadowActivity = Shadows.shadowOf(activity);</span><br><span class="line">    <span class="comment">// 借助Shadow类获取启动下一Activity的Intent</span></span><br><span class="line">    Intent nextIntent = shadowActivity.getNextStartedActivity();</span><br><span class="line">    <span class="comment">// 校验Intent的正确性</span></span><br><span class="line">    assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Config配置"><a href="#Config配置" class="headerlink" title="@Config配置"></a>@Config配置</h2><p>可以通过<code>@Config</code>定制Robolectric的运行时的行为。这个注解可以用来注释类和方法，如果类和方法同时使用了@Config，那么方法的设置会覆盖类的设置。你可以创建一个基类，用@Config配置测试参数，这样，其他测试用例就可以共享这个配置了</p><h2 id="配置SDK版本"><a href="#配置SDK版本" class="headerlink" title="配置SDK版本"></a>配置SDK版本</h2><p>Robolectric会根据manifest文件配置的targetSdkVersion选择运行测试代码的SDK版本，如果你想指定sdk来运行测试用例，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(sdk = Build.VERSION_CODES.JELLY_BEAN)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(sdk = Build.VERSION_CODES.KITKAT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Application类"><a href="#配置Application类" class="headerlink" title="配置Application类"></a>配置Application类</h2><p>Robolectric会根据manifest文件配置的Application配置去实例化一个Application类，如果你想在测试用例中重新指定，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(application = CustomApplicationOverride.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定Resource路径"><a href="#指定Resource路径" class="headerlink" title="指定Resource路径"></a>指定Resource路径</h2><p>Robolectric可以让你配置manifest、resource和assets路径，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(manifest = <span class="string">"some/build/path/AndroidManifest.xml"</span>,</span><br><span class="line">        assetDir = <span class="string">"some/build/path/assetDir"</span>,</span><br><span class="line">        resourceDir = <span class="string">"some/build/path/resourceDir"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(manifest = <span class="string">"other/build/path/AndroidManifest.xml"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用第三方Library-Resources"><a href="#使用第三方Library-Resources" class="headerlink" title="使用第三方Library Resources"></a>使用第三方Library Resources</h2><p>当Robolectric测试的时候，会尝试加载所有应用提供的资源，但如果你需要使用第三方库中提供的资源文件，你可能需要做一些特别的配置。不过如果你使用gradle来构建Android应用，这些配置就不需要做了，因为Gradle Plugin会在build的时候自动合并第三方库的资源，但如果你使用的是Maven，那么你需要配置libraries变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(libraries = &#123;</span><br><span class="line">    <span class="string">"build/unpacked-libraries/library1"</span>,</span><br><span class="line">    <span class="string">"build/unpacked-libraries/library2"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用限定的资源文件"><a href="#使用限定的资源文件" class="headerlink" title="使用限定的资源文件"></a>使用限定的资源文件</h2><p>Android会在运行时加载特定的资源文件，如根据设备屏幕加载不同分辨率的图片资源、根据系统语言加载不同的string.xml，在Robolectric测试当中，你也可以进行一个限定，让测试程序加载特定资源.多个限定条件可以用破折号拼接在在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用qualifiers加载对应的资源文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Config</span>(qualifiers = <span class="string">"zh-rCN"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context context = RuntimeEnvironment.application;</span><br><span class="line">    assertThat(context.getString(R.string.app_name), is(<span class="string">"单元测试Demo"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties文件"><a href="#Properties文件" class="headerlink" title="Properties文件"></a>Properties文件</h2><p>如果你嫌通过注解配置上面的东西麻烦，你也可以把以上配置放在一个Properties文件之中，然后通过@Config指定配置文件，比如，首先创建一个配置文件robolectric.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 放置Robolectric的配置选项:</span><br><span class="line">sdk=21</span><br><span class="line">manifest=some/build/path/AndroidManifest.xml</span><br><span class="line">assetDir=some/build/path/assetDir</span><br><span class="line">resourceDir=some/build/path/resourceDir</span><br></pre></td></tr></table></figure><p>然后把robolectric.properties文件放到src/test/resources目录下，运行的时候，会自动加载里面的配置</p><h2 id="系统属性配置"><a href="#系统属性配置" class="headerlink" title="系统属性配置"></a>系统属性配置</h2><ul><li>robolectric.offline：true代表关闭运行时获取jar包</li><li>robolectric.dependency.dir：当处于offline模式的时候，指定运行时的依赖目录</li><li>robolectric.dependency.repo.id：设置运行时获取依赖的Maven仓库ID，默认是sonatype</li><li>robolectric.dependency.repo.url：设置运行时依赖的Maven仓库地址，默认是<a href="https://oss.sonatype.org/content/groups/public/" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/public/</a></li><li>robolectric.logging.enabled：设置是否打开调试开关</li></ul><p>以上设置可以通过Gradle进行配置，如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    testOptions &#123;</span><br><span class="line">        unitTests.all &#123;</span><br><span class="line">            systemProperty <span class="string">'robolectric.dependency.repo.url'</span>, <span class="string">'https://local-mirror/repo'</span></span><br><span class="line">            systemProperty <span class="string">'robolectric.dependency.repo.id'</span>, <span class="string">'local'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驱动Activity生命周期"><a href="#驱动Activity生命周期" class="headerlink" title="驱动Activity生命周期"></a>驱动Activity生命周期</h2><p>利用<code>ActivityController</code>我们可以让Activity执行相应的生命周期方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLifecycle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Activity控制器</span></span><br><span class="line">    ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class);</span><br><span class="line">    MainActivity activity = controller.get();</span><br><span class="line">    assertNull(activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performCreate方法</span></span><br><span class="line">    controller.create();</span><br><span class="line">    assertEquals(<span class="string">"onCreate"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performStart方法</span></span><br><span class="line">    controller.start();</span><br><span class="line">    assertEquals(<span class="string">"onStart"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performResume方法</span></span><br><span class="line">    controller.resume();</span><br><span class="line">    assertEquals(<span class="string">"onResume"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performPause方法</span></span><br><span class="line">    controller.pause();</span><br><span class="line">    assertEquals(<span class="string">"onPause"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performStop方法</span></span><br><span class="line">    controller.stop();</span><br><span class="line">    assertEquals(<span class="string">"onStop"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performRestart方法</span></span><br><span class="line">    controller.restart();</span><br><span class="line">    <span class="comment">// 注意此处应该是onStart，因为performRestart不仅会调用restart，还会调用onStart</span></span><br><span class="line">    assertEquals(<span class="string">"onStart"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performDestroy方法</span></span><br><span class="line">    controller.destroy();</span><br><span class="line">    assertEquals(<span class="string">"onDestroy"</span>, activity.getLifecycleState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ActivityController，我们可以模拟各种生命周期的变化。但是要注意，我们虽然可以随意调用Activity的生命周期，但是Activity生命周期切换有自己的检测机制，我们要遵循Activity的生命周期规律。比如，如果当前Activity并非处于stop状态，测试代码去调用了controller.restart方法，此时Activity是不会回调onRestart和onStart的。</p><p>除了控制生命周期，还可以在启动Activity的时候传递Intent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动Activity的时候传递Intent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartActivityWithIntent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"test"</span>, <span class="string">"HelloWorld"</span>);</span><br><span class="line">    Activity activity = Robolectric.buildActivity(MainActivity.class).withIntent(intent).create().get();</span><br><span class="line">    assertEquals(<span class="string">"HelloWorld"</span>, activity.getIntent().getExtras().getString(<span class="string">"test"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onRestoreInstanceState回调中传递Bundle：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * savedInstanceState会在onRestoreInstanceState回调中传递给Activity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSavedInstanceState</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Bundle savedInstanceState = <span class="keyword">new</span> Bundle();</span><br><span class="line">    Robolectric.buildActivity(MainActivity.class).create().restoreInstanceState(savedInstanceState).get();</span><br><span class="line">    <span class="comment">// verify something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在真实环境下，视图是在onCreate之后的某一时刻在attach到Window上的，在此之前，View是处于不可操作状态的，你不能点击它。在Activity的onPostResume方法调用之后，View才会attach到Window之中。但是，在Robolectric之中，我们可以用控制器的<code>visible</code>方法使得View变为可见，变为可见之后，就可以模拟点击事件了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVisible</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class);</span><br><span class="line">    MainActivity activity = controller.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performCreate并且设置视图visible</span></span><br><span class="line">    controller.create().visible();</span><br><span class="line">    <span class="comment">// 触发点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_button1).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    assertEquals(shadowOf(activity).getNextStartedActivity().getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="追加模块"><a href="#追加模块" class="headerlink" title="追加模块"></a>追加模块</h2><p>为了减少依赖包的大小，Robolectric的shadows类成了好几部分：</p><table><thead><tr><th>SDK Package</th><th>Robolectric Add-On Package</th></tr></thead><tbody><tr><td>com.android.support.support-v4</td><td>org.robolectric:shadows-support-v4</td></tr><tr><td>com.android.support.multidex</td><td>org.robolectric:shadows-multidex</td></tr><tr><td>com.google.android.gms:play-services</td><td>org.robolectric:shadows-play-services</td></tr><tr><td>com.google.android.maps:maps</td><td>org.robolectric:shadows-maps</td></tr><tr><td>org.apache.httpcomponents:httpclient</td><td>org.robolectric:shadows-httpclient</td></tr></tbody></table><p>用户可以根据自身需求添加以下依赖包，如</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    testCompile <span class="string">'org.robolectric:robolectric:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-support-v4:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-multidex:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-play-services:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-maps:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-httpclient:3.1.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Shadow类"><a href="#自定义Shadow类" class="headerlink" title="自定义Shadow类"></a>自定义Shadow类</h2><ol><li>Shadow类需要一个public的无参构造方法以方便Robolectric框架可以实例化它，通过@Implements注解与原始类关联在一起</li><li>若原始类有<code>有参构造方法</code>，在Shadow类中定义public void类型的名为<code>__constructor__</code>的方法，且方法参数与原始类的构造方法参数一直</li><li>定义与原始类方法签名一致的方法，在里面重写实现，Shadow方法需用@Implementation进行注解</li></ol><p>下面我们来创建RobolectricBean的Shadow类<br>原始类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span>    color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RobolectricBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shadow类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建&#123;<span class="doctag">@link</span> RobolectricBean&#125;的影子类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Implements</span>(RobolectricBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowRobolectricBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@RealObject</span>注解可以访问原始对象，但注意，通过<span class="doctag">@RealObject</span>注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法</span></span><br><span class="line"><span class="comment">     * 只能用来访问原始类的field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RealObject</span></span><br><span class="line">    RobolectricBean realBean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要一个无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowRobolectricBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应原始类的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 对应原始类构造方法的传入参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">__constructor__</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        realBean.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始对象的方法被调用的时候，Robolectric会根据方法签名查找对应的Shadow方法并调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, I ma shadow of RobolectricBean: "</span> + realBean.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realBean.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        realBean.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shadow类中访问原始类的field"><a href="#Shadow类中访问原始类的field" class="headerlink" title="Shadow类中访问原始类的field"></a>Shadow类中访问原始类的field</h2><p>Shadow类中可以定义一个原始类的成员变量，并用@RealObject注解，这样，Shadow类就能访问原始类的field了，但是注意，通过@RealObject注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法，只能用它来访问原始类的field。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Implements</span>(Point.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RealObject</span> <span class="keyword">private</span> Point realPoint;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">__constructor__</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        realPoint.x = x;</span><br><span class="line">        realPoint.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在测试用例中让Shadow生效"><a href="#如何在测试用例中让Shadow生效" class="headerlink" title="如何在测试用例中让Shadow生效"></a>如何在测试用例中让Shadow生效</h2><p>在Config注解中添加<code>shadows</code>参数，指定对应的Shadow生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(shadows = ShadowRobolectricBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，自定义的Shadow类不能通过<code>Shadows.shadowOf()</code>获取，需要用<code>ShadowExtractor.extract()</code>来获取，获取之后进行类型转换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShadowRobolectricBean shadowBean = (ShadowRobolectricBean) ShadowExtractor.extract(bean);</span><br></pre></td></tr></table></figure><h1 id="常用测试场景"><a href="#常用测试场景" class="headerlink" title="常用测试场景"></a>常用测试场景</h1><h2 id="页面跳转验证"><a href="#页面跳转验证" class="headerlink" title="页面跳转验证"></a>页面跳转验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJump</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume</span></span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    <span class="comment">// 触发按钮点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_jump).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的Shadow类</span></span><br><span class="line">    ShadowActivity shadowActivity = Shadows.shadowOf(activity);</span><br><span class="line">    <span class="comment">// 借助Shadow类获取启动下一Activity的Intent</span></span><br><span class="line">    Intent nextIntent = shadowActivity.getNextStartedActivity();</span><br><span class="line">    <span class="comment">// 校验Intent的正确性</span></span><br><span class="line">    assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UI组件状态验证"><a href="#UI组件状态验证" class="headerlink" title="UI组件状态验证"></a>UI组件状态验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证UI组件状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckBoxState</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    CheckBox checkBox = (CheckBox) activity.findViewById(R.id.activity_main_check_box);</span><br><span class="line">    <span class="comment">// 验证CheckBox初始状态</span></span><br><span class="line">    assertFalse(checkBox.isChecked());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击按钮反转CheckBox状态</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_switch_check_box).performClick();</span><br><span class="line">    <span class="comment">// 验证状态是否正确</span></span><br><span class="line">    assertTrue(checkBox.isChecked());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击按钮反转CheckBox状态</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_switch_check_box).performClick();</span><br><span class="line">    <span class="comment">// 验证状态是否正确</span></span><br><span class="line">    assertFalse(checkBox.isChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Dialog"><a href="#验证Dialog" class="headerlink" title="验证Dialog"></a>验证Dialog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证Dialog是否正确弹出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDialog</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    AlertDialog dialog = ShadowAlertDialog.getLatestAlertDialog();</span><br><span class="line">    <span class="comment">// 判断Dialog尚未弹出</span></span><br><span class="line">    assertNull(dialog);</span><br><span class="line"></span><br><span class="line">    activity.findViewById(R.id.activity_main_show_dialog).performClick();</span><br><span class="line">    dialog = ShadowAlertDialog.getLatestAlertDialog();</span><br><span class="line">    <span class="comment">// 判断Dialog已经弹出</span></span><br><span class="line">    assertNotNull(dialog);</span><br><span class="line">    <span class="comment">// 获取Shadow类进行验证</span></span><br><span class="line">    ShadowAlertDialog shadowDialog = shadowOf(dialog);</span><br><span class="line">    assertEquals(<span class="string">"AlertDialog"</span>, shadowDialog.getTitle());</span><br><span class="line">    assertEquals(<span class="string">"Oops, now you see me ~"</span>, shadowDialog.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Toast"><a href="#验证Toast" class="headerlink" title="验证Toast"></a>验证Toast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证Toast是否正确弹出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToast</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    Toast toast = ShadowToast.getLatestToast();</span><br><span class="line">    <span class="comment">// 判断Toast尚未弹出</span></span><br><span class="line">    assertNull(toast);</span><br><span class="line"></span><br><span class="line">    activity.findViewById(R.id.activity_main_show_toast).performClick();</span><br><span class="line">    toast = ShadowToast.getLatestToast();</span><br><span class="line">    <span class="comment">// 判断Toast已经弹出</span></span><br><span class="line">    assertNotNull(toast);</span><br><span class="line">    <span class="comment">// 获取Shadow类进行验证</span></span><br><span class="line">    ShadowToast shadowToast = shadowOf(toast);</span><br><span class="line">    assertEquals(Toast.LENGTH_SHORT, shadowToast.getDuration());</span><br><span class="line">    assertEquals(<span class="string">"oops"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Fragment"><a href="#验证Fragment" class="headerlink" title="验证Fragment"></a>验证Fragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragmentTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyFragment myFragment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        myFragment = <span class="keyword">new</span> MyFragment();</span><br><span class="line">        <span class="comment">// 把Fragment添加到Activity中</span></span><br><span class="line">        FragmentTestUtil.startFragment(myFragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFragment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertNotNull(myFragment.getView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证BroadcastReceiver"><a href="#验证BroadcastReceiver" class="headerlink" title="验证BroadcastReceiver"></a>验证BroadcastReceiver</h2><p>首先看下广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广播的测试点可以包含两个方面</p><ol><li>验证应用程序是否注册了该广播</li><li>验证广播接收器的处理逻辑是否正确，关于逻辑是否正确，可以直接人为的触发onReceive()方法，让然后进行验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ShadowApplication shadowApplication = ShadowApplication.getInstance();</span><br><span class="line"></span><br><span class="line">        String action = <span class="string">"ut.cn.unittestdemo.receiver"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证是否注册了相应的Receiver</span></span><br><span class="line">        assertTrue(shadowApplication.hasReceiverForIntent(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restReceive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String action = <span class="string">"ut.cn.unittestdemo.receiver"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line">        intent.putExtra(<span class="string">"EXTRA_USERNAME"</span>, <span class="string">"HansChen"</span>);</span><br><span class="line"></span><br><span class="line">        MyReceiver myReceiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">        myReceiver.onReceive(RuntimeEnvironment.application, intent);</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Service"><a href="#验证Service" class="headerlink" title="验证Service"></a>验证Service</h2><p>Service和Activity一样，都有生命周期，Robolectric也提供了Service的生命周期控制器，使用方式和Activity类似，这里就不做详细解释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceController&lt;TestService&gt; controller;</span><br><span class="line">    <span class="keyword">private</span> TestService                    testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        controller = Robolectric.buildService(TestService.class);</span><br><span class="line">        testService = controller.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制Service生命周期进行验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLifecycle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        controller.create();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.startCommand(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.bind();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.unbind();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.destroy();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Android的单元测试可以分为两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Local unit tests：运行于本地JVM&lt;/li&gt;
&lt;li&gt;Instrumented test：运行于真机或者模拟器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用Local测试，需要保证测试过程中不会调用Android系统API，否则会抛出RuntimeException异常，因为Local测试是直接跑在本机JVM的，而之所以我们能使用Android系统API，是因为编译的时候，我们依赖了一个名为“android.jar”的jar包，但是jar包里所有方法都是直接抛出了一个RuntimeException，是没有任何任何实现的，这只是Android为了我们能通过编译提供的一个Stub！当APP运行在真实的Android系统的时候，由于类加载机制，会加载位于framework的具有真正实现的类。由于我们的Local是直接在PC上运行的，所以调用这些系统API便会出错。&lt;br&gt;那么问题来了，我们既要使用Local测试，但测试过程又难免遇到调用系统API那怎么办？其中一个方法就是mock objects，比如借助Mockito，另外一种方式就是使用&lt;code&gt;Robolectric&lt;/code&gt;， Robolectric就是为解决这个问题而生的。它实现一套JVM能运行的Android代码，然后在unit test运行的时候去截取android相关的代码调用，然后转到他们的他们实现的Shadow代码去执行这个调用的过程&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="http://blog.hanschen.site/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="单元测试" scheme="http://blog.hanschen.site/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Robolectric" scheme="http://blog.hanschen.site/tags/Robolectric/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板方法模式和策略模式</title>
    <link href="http://blog.hanschen.site/2016/12/01/design-patterns-template-and-strategy/"/>
    <id>http://blog.hanschen.site/2016/12/01/design-patterns-template-and-strategy/</id>
    <published>2016-11-30T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们知道，OOP三个基本特征是:封装、继承、多态。通过继承，我们可以基于差异编程，也就是说，对于一个满足我们大部分需求的类，可以创建它的一个子类并只改变我们不期望的那部分。但是在实际使用中，继承很容易被过度使用，并且过度使用的代价是比较高的，所以我们减少了继承的使用，使用组合或委托代替</p><blockquote><p>优先使用对象组合而不是类继承</p></blockquote><p>在本文中，我们会分别介绍<code>模板方法模式</code>和<code>策略模式</code>，这两个模式分别使用了继承和委托两种方式。这两种模式解决的问题是类似的，经常可以互换使用，它们都可以分离通用的算法和具体的上下文。比如我们有一个通用的算法，算法有不同的实现方式，为了遵循依赖倒置原则，我们希望算法不依赖于具体实现。</p><a id="more"></a><p>本文冒泡排序法来进行举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (needSwap(array, j)) &#123;</span><br><span class="line">                    swap(array, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index] &gt; array[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们实现的冒泡排序算法，这个sort方法可以对int数组进行排序。但我们发现，这种写法的扩展性是不强的，如果我们要实现double数组排序呢？如果我们需要排序的是一个对象数组？难道需要各自定义一个方法吗？如果它们都使用冒泡排序算法，那么sort的算法逻辑肯定是相似的，有没有一种方法能让这个算法逻辑复用呢？下面用模板方法模式和策略模式对它进行改造</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>模板方法模式:定义一个算法的骨架，将骨架中的特定步骤延迟到子类中。模板方法模式使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤</p></blockquote><p>下图是用模板方法模式对冒泡排序重构后的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-29-33.png" alt="2019-9-2-11-29-33.png"></p><p>首先，我们在BubbleSorter的sort方法中定义算法骨架，再定义一些延迟到子类中的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(T array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        setArray(array);</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (needSwap(j)) &#123;</span><br><span class="line">                    swap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>BubbleSorter</code>类，我们就可以创建任意不同类型的对象排序的简单派生类，比如创建<code>IntBubbleSorter</code>去排序整型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class IntBubbleSorter extends BubbleSorter&lt;int[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如创建<code>DoubleBubbleSorter</code>去排序双精度型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleBubbleSorter extends BubbleSorter&lt;double[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">double</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至我们<strong>不仅限于对数组</strong>排序，还可以对List集合排序，比如创建<code>IntegerListBubbleSorter</code>对List集合进行冒泡排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerListBubbleSorter</span> <span class="keyword">extends</span> <span class="title">BubbleSorter</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list == <span class="keyword">null</span> ? <span class="number">0</span> : list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list != <span class="keyword">null</span> &amp;&amp; (list.get(index) &gt; list.get(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = list.get(index);</span><br><span class="line">        list.set(index, list.get(index + <span class="number">1</span>));</span><br><span class="line">        list.set(index + <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义上述类之后，我们看下怎么使用上面的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//对整型数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> operations = <span class="keyword">new</span> IntBubbleSorter().sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(intArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对double数组排序</span></span><br><span class="line">        <span class="keyword">double</span>[] doubleArray = &#123;<span class="number">9.9</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, <span class="number">6.6</span>, <span class="number">5.5</span>, <span class="number">4.4</span>, <span class="number">3.3</span>, <span class="number">2.2</span>, <span class="number">1.1</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">        operations = <span class="keyword">new</span> DoubleBubbleSorter().sort(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(doubleArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        operations = <span class="keyword">new</span> IntegerListBubbleSorter().sort(list);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", list:"</span> + list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法模式展示了经典重用的一种形式，通用算法被放在基类中，通过继承在不同的子类中实现该通用算法。我们通过定义通用类BubbleSorter，把冒泡排序的算法骨架放在基类，然后实现不同的子类分别对int数组、double数组、List集合进行排序。但这样是有代价的，因为继承是非常强的关系，派生类不可避免地与基类绑定在一起了。但如果我现在需要用快速排序而不是冒泡排序来进行排序，但快速排序却没有办法重用<code>setArray</code>、<code>getLength</code>、<code>needSwap</code>和<code>swap</code>方法了。不过，策略模式提供了另一种可选的方案</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换，下面用策略模式对冒泡排序进行重构</p><p>下图是用策略模式对冒泡排序重构后的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-35-32.png" alt="2019-9-2-11-35-32.png"></p><p>首先定义一个BubbleSorter类，它持有一个抽象策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象策略接口，可以有不同的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SortHandler&lt;T&gt; sortHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BubbleSorter</span><span class="params">(SortHandler&lt;T&gt; sortHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortHandler = sortHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(T array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sortHandler.setArray(array);</span><br><span class="line">        <span class="keyword">int</span> length = sortHandler.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (sortHandler.needSwap(j)) &#123;</span><br><span class="line">                    sortHandler.swap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>IntSortHandler</code>对整型数组进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class IntSortHandler implements SortHandler&lt;int[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>DoubleSortHandler</code>对双精度型数组进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleSortHandler implements SortHandler&lt;double[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">double</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>IntegerListSortHandler</code>对List集合进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerListSortHandler</span> <span class="keyword">implements</span> <span class="title">SortHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list == <span class="keyword">null</span> ? <span class="number">0</span> : list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list != <span class="keyword">null</span> &amp;&amp; (list.get(index) &gt; list.get(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = list.get(index);</span><br><span class="line">        list.set(index, list.get(index + <span class="number">1</span>));</span><br><span class="line">        list.set(index + <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义上述类之后，我们看下怎么使用策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对整型数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        BubbleSorter&lt;<span class="keyword">int</span>[]&gt; intBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> IntSortHandler());</span><br><span class="line">        <span class="keyword">int</span> operations = intBubbleSorter.sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(intArray));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对double数组排序</span></span><br><span class="line">        <span class="keyword">double</span>[] doubleArray = &#123;<span class="number">9.9</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, <span class="number">6.6</span>, <span class="number">5.5</span>, <span class="number">4.4</span>, <span class="number">3.3</span>, <span class="number">2.2</span>, <span class="number">1.1</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">        BubbleSorter&lt;<span class="keyword">double</span>[]&gt; doubleBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> DoubleSortHandler());</span><br><span class="line">        operations = doubleBubbleSorter.sort(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(doubleArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        BubbleSorter&lt;List&lt;Integer&gt;&gt; integerListBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> IntegerListSortHandler());</span><br><span class="line">        operations = integerListBubbleSorter.sort(list);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", list:"</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式不是将通用方法放到基类中，而是把它放进<code>BubbleSorter</code>的sort方法中，把排序算法中必须调用的抽象方法定义在<code>SortHandler</code>接口中，从这个接口中派生出不同的子类。把派生出的子类传给BubbleSorter后，sort方法就可以把具体工作委托给接口去完成。注意：SortHandler对BubbleSorter是一无所知的，它不依赖于冒泡排序的具体实现，这个和模板方法模式是不同的。如果其他排序算法也需要用到SortHandler，完全也可以在相关的排序算法中使用SortHandler</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法模式和策略模式都可以用来分离高层的算法和低层的具体实现细节，都允许高层的算法独立于它的具体实现细节重用。但策略模式还有一个额外的好处就是允许具体实现细节独立于高层的算法重用，但这也以一些额外的复杂性、内存以及运行事件开销作为代价</p><p><a href="https://github.com/shensky711/awesome-demo/tree/master/Patterns" target="_blank" rel="noopener">文中示例代码下载：https://github.com/shensky711/awesome-demo/tree/master/Patterns</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;我们知道，OOP三个基本特征是:封装、继承、多态。通过继承，我们可以基于差异编程，也就是说，对于一个满足我们大部分需求的类，可以创建它的一个子类并只改变我们不期望的那部分。但是在实际使用中，继承很容易被过度使用，并且过度使用的代价是比较高的，所以我们减少了继承的使用，使用组合或委托代替&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优先使用对象组合而不是类继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本文中，我们会分别介绍&lt;code&gt;模板方法模式&lt;/code&gt;和&lt;code&gt;策略模式&lt;/code&gt;，这两个模式分别使用了继承和委托两种方式。这两种模式解决的问题是类似的，经常可以互换使用，它们都可以分离通用的算法和具体的上下文。比如我们有一个通用的算法，算法有不同的实现方式，为了遵循依赖倒置原则，我们希望算法不依赖于具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板方法模式" scheme="http://blog.hanschen.site/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://blog.hanschen.site/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式（Factory）</title>
    <link href="http://blog.hanschen.site/2016/11/26/design-patterns-factory/"/>
    <id>http://blog.hanschen.site/2016/11/26/design-patterns-factory/</id>
    <published>2016-11-25T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>根据<code>依赖倒置原则</code>，我们知道，我们应优先依赖抽象类而不是具体类。在应用开发过程中，有很多实体类都是非常易变的，依赖它们会带来问题，所以我们更应该依赖于抽象接口，已使我们免受大多数变化的影响。<br><code>工厂模式（Factory）</code>允许我们只依赖于抽象接口就能创建出具体对象的实例，所以在开发中，如果具体类是高度易变的，那么该模式就非常有用。</p><p>接下来我们就通过代码举例说明什么是工厂模式</p><a id="more"></a><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>假设我们现在有个需求：把一段数据用Wi-Fi或者蓝牙发送出去。<br>需求很简单是吧？刷刷刷就写下了以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        sendDataByWiFi(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sendDataByBluetooth(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDataByWiFi</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send data via Wi-Fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDataByBluetooth</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send data via Bluetooth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码扩展性并不高，违反了开放封闭原则。比如现在又有了个新的需求，需要用zigbee把数据发送出去，就得再新增一个sendDataByZigbee方法了，而且还得修改onClick里面的逻辑。那么比较好的方法是怎么样的呢？</p><p>定义一个数据发送器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据发送器Sender</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现WiFi数据发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sender的实现类，通过Wi-Fi发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiFiSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send data by Wi-Fi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现蓝牙数据发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sender的实现类，通过蓝牙发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send data by Bluetooth"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，原来发送数据的地方就改为了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Sender sender;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        sender = <span class="keyword">new</span> WiFiSender();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sender = <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">    &#125;</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有觉得代码优雅了一点？但是随着发送器Sender的实现类越来越多，每增加一个实现类，就需要在onClick里面实例化相应的实现类，能不能用一个单独的类来做这个创造实例的过程呢？这就是我们讲到的工厂。我们新增一个工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createSender</span><span class="params">(String mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Wi-Fi"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WiFiSender();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Bluetooth"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal type: "</span> + mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，怎么实例化数据发送器我们也不用管了，最终代码变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Sender sender = SimpleFactory.createSender(mode);</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里我们就完成了简单工厂模式的应用了，下图就是简单工厂模式的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-28-47.png" alt="2019-9-2-11-28-47.png"></p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式的优点在于工厂类包含了必要的判断逻辑，根据传入的参数动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但是这里还是会有个问题，假设上面例子中新增了一个zigbee发送器，那么一定是需要修改简单工厂类的，也就是说，我们不但对扩展开放了，对修改也开放了，这是不好的。解决的方法是使用工厂方法模式，工厂方法模式是指<strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类</strong>。下面还是通过代码来说明：</p><p>在简单工厂模式的基础上，让我们对工厂类也升级一下，首先定义一个工厂类接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sender <span class="title">createSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为每一个发送器的实现类各创建一个具体的工厂方法去实现这个接口</p><p>定义WiFiSender的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiFiSenderFactory</span> <span class="keyword">implements</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WiFiSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义BluetoothSender的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothSenderFactory</span> <span class="keyword">implements</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使有新的Sender实现类加进来，我们只需要新增相应的工厂类就行了，不需要修改原有的工厂，下图就是工厂方法模式的结构图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-28-17.png" alt="2019-9-2-11-28-17.png"></p><p>客户端调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    SenderFactory factory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> WiFiSenderFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> BluetoothSenderFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    Sender sender = factory.createSender();</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能已经发现了，工厂方法模式实现时，客户端需要决定实例化哪一个工厂类，相比于简单工厂模式，客户端多了一个选择判断的问题，也就是说，<strong>工厂方法模式把简单工厂模式的内部逻辑判断移到了客户端！</strong>你想要加功能，本来是修改简单工厂类的，现在改为修改客户端。但是这样带来的好处是整个工厂和产品体系都没有“修改”的变化，只有“扩展”的变化，完全符合了开放封闭原则。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂模式和工厂方法模式都封装了对象的创建，它们使得高层策略模块在创建类的实例时无需依赖于这些类的具体实现。但是两种工厂模式之间又有差异：</p><ul><li>简单工厂模式：最大的优点在于工厂类包含了必要的判断逻辑，根据客户端的条件动态地实例化相关的类。但这也是它的缺点，当扩展功能的时候，需要修改工厂方法，违反了开放封闭原则</li><li>工厂方法模式：符合开放封闭原则，但这带来的代价是扩展的时候要增加相应的工厂类，增加了开发量，而且需要修改客户端代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;根据&lt;code&gt;依赖倒置原则&lt;/code&gt;，我们知道，我们应优先依赖抽象类而不是具体类。在应用开发过程中，有很多实体类都是非常易变的，依赖它们会带来问题，所以我们更应该依赖于抽象接口，已使我们免受大多数变化的影响。&lt;br&gt;&lt;code&gt;工厂模式（Factory）&lt;/code&gt;允许我们只依赖于抽象接口就能创建出具体对象的实例，所以在开发中，如果具体类是高度易变的，那么该模式就非常有用。&lt;/p&gt;
&lt;p&gt;接下来我们就通过代码举例说明什么是工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://blog.hanschen.site/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Factory" scheme="http://blog.hanschen.site/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>Fragment源码分析</title>
    <link href="http://blog.hanschen.site/2016/11/15/fragment/"/>
    <id>http://blog.hanschen.site/2016/11/15/fragment/</id>
    <published>2016-11-14T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>Fragment</code>表示 Activity 中的行为或用户界面部分。您可以将多个 Fragment 组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个 Fragment。您可以将 Fragment 视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除 Fragment。<br>Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有 Fragment 也会暂停；当 Activity 被销毁时，所有 Fragment 也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个 Fragment，如添加或移除它们。 当您执行此类 Fragment 事务时，您也可以将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生 Fragment 事务的记录。 返回栈让用户可以通过按返回按钮撤消 Fragment 事务（后退）。</p><p>当您将 Fragment 作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且 Fragment 会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明Fragment，将其作为 <code>&lt;fragment&gt;</code> 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，Fragment 并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的 Fragment 用作 Activity 的不可见工作线程。</p><p>本文将通过分析源码，对 Fragment 的创建、销毁以及生命周期做一个更深入的认识。</p><p>建议读者在看这篇文章的时候，先看下<a href="http://blog.csdn.net/shensky711/article/details/53132952" target="_blank" rel="noopener">Fragment事务管理源码分析</a>，对Fragment管理类先有一个比较清楚的认识。</p><a id="more"></a><h1 id="分析入口"><a href="#分析入口" class="headerlink" title="分析入口"></a>分析入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造并显示Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containerViewId 容器控件id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz             Fragment类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(@IdRes <span class="keyword">int</span> containerViewId, Class&lt;? extends Fragment&gt; clz)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = getFragmentManager();</span><br><span class="line">    FragmentTransaction ft = fm.beginTransaction();<span class="comment">//开始事务管理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Fragment f = clz.newInstance();</span><br><span class="line">        ft.add(containerViewId, f, clz.getName());<span class="comment">//添加操作</span></span><br><span class="line">        ft.commit();<span class="comment">//提交事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是动态地往<code>containerViewId</code>里添加一个Fragment并让它显示出来，可以看到，这个涉及到Fragment的事务管理，详细可以参考<a href="http://blog.csdn.net/shensky711/article/details/53132952" target="_blank" rel="noopener">Fragment事务管理源码分析</a>，这里就不再阐述了。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="BackStackRecord-run"><a href="#BackStackRecord-run" class="headerlink" title="BackStackRecord#run"></a>BackStackRecord#run</h2><p>调用了commit之后，真正执行的地方是在BackStackRecord的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line">        beginTransition(firstOutFragments, lastInFragments, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表，根据cmd事务类型依次处理事务</span></span><br><span class="line">    Op op = mHead;</span><br><span class="line">    <span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">                <span class="comment">//添加一个新的Fragment</span></span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REPLACE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                <span class="keyword">int</span> containerId = f.mContainerId;</span><br><span class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        Fragment old = mManager.mAdded.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (old == f) &#123;</span><br><span class="line">                                op.fragment = f = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (op.removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                &#125;</span><br><span class="line">                                op.removed.add(old);</span><br><span class="line">                                old.mNextAnim = op.exitAnim;</span><br><span class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mManager.removeFragment(old, mTransition, mTransitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f.mNextAnim = op.enterAnim;</span><br><span class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.removeFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.hideFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.showFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.detachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.attachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">            mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们调用的是add操作，所以执行的代码片段是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">    Fragment f = op.fragment;</span><br><span class="line">    f.mNextAnim = op.enterAnim;</span><br><span class="line">    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>op.fragment：showFragment中创建的Fragment实例，并且现在Fragment的mTag、mFragmentId、mContainerId已被初始化过了</li><li>op.enterAnim:入场动画，可以先不管</li><li>mManager：FragmentManagerImpl实例</li></ul><h2 id="FragmentManagerImpl-addFragment"><a href="#FragmentManagerImpl-addFragment" class="headerlink" title="FragmentManagerImpl#addFragment"></a>FragmentManagerImpl#addFragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, <span class="keyword">boolean</span> moveToStateNow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已添加的Fragment列表</span></span><br><span class="line">    <span class="keyword">if</span> (mAdded == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdded = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Fragment的mIndex，并把Fragment添加到mActive列表</span></span><br><span class="line">    makeActive(fragment);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否被detach。默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (!fragment.mDetached) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把Fragment添加到mAdded列表</span></span><br><span class="line">        mAdded.add(fragment);</span><br><span class="line">        <span class="comment">//设置Fragment标记位</span></span><br><span class="line">        fragment.mAdded = <span class="keyword">true</span>;</span><br><span class="line">        fragment.mRemoving = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断是否需要刷新菜单</span></span><br><span class="line">        <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这次分析中moveToStateNow为false，moveToState方法在本方法外层方法中调用</span></span><br><span class="line">        <span class="keyword">if</span> (moveToStateNow) &#123;</span><br><span class="line">            moveToState(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addFragment里面把Fragment加入mActive和mAdded列表，并且设置标记为<code>fragment.mAdded</code>为true，<code>fragment.mRemoving</code>为false。<br>执行完ADD操作后，执行moveToState，moveToState顾名思义，就是把Fragment变为某种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mManager.mCurState的状态很重要，我们下面会分析它现在处于什么状态</span></span><br><span class="line">mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">        mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加本次操作到回退栈中</span></span><br><span class="line"><span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">    mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment状态"><a href="#Fragment状态" class="headerlink" title="Fragment状态"></a>Fragment状态</h2><p>我们知道Fragment的生命周期是依赖于Activity的，比如Activity处于onResume,那么Fragment也会处于onResume状态，这里的参数mManager.mCurState对应的状态有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_STATE = -<span class="number">1</span>;   <span class="comment">// Invalid state used as a null value.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// Not yet created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// The activity has finished its creation.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOPPED = <span class="number">3</span>;          <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">4</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">5</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure><p>mCurState的初始状态是Fragment.INITIALIZING，那么在BackStackRecord中调用moveToState的时候，mCurState是什么值呢？它是会受Activity生命周期影响而变化的，我们来看下<code>FragmentActivity</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定FragmentManager</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分发Fragment的create事件</span></span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHost.mFragmentManager.dispatchCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mStateSaved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//注意这里设置了新的state</span></span><br><span class="line">    moveToState(Fragment.CREATED, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    moveToState(newState, <span class="number">0</span>, <span class="number">0</span>, always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitStyle, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">//给mCurState赋值</span></span><br><span class="line">    mCurState = newState;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onCreate中把mCurState变为<code>Fragment.CREATED</code>状态了，Activity的其他生命周期方法回调的时候，也会改变这个状态，大致整理如下：</p><ul><li>onCreate：Fragment.CREATED</li><li>onStart：Fragment.ACTIVITY_CREATED–&gt;Fragment.STARTED (Fragment.ACTIVITY_CREATED只会在Activity创建之后触发一次，Fragment.STARTED每次onStart的时候都会触发)</li><li>onResume：Fragment.RESUMED</li><li>onPause：Fragment.STARTED</li><li>onStop：Fragment.STOPPED</li><li>onDestroy：Fragment.INITIALIZING</li></ul><p>下面是一张状态迁移图：<br><img src="http://image.hanschen.site/master/2019-9-2-11-22-55.png" alt="2019-9-2-11-22-55.png"></p><p>所以随着Activity生命周期的推进，Activity内所有Fragment的生命周期也会跟着推进。<strong>从Activity创建到显示出来，最后会处于onResume状态，那么我们这次就直接分析当前Activity处于onResume调用之后的情形好了。所以假定现在mCurState为Fragment.RESUMED</strong>，</p><p>让我们继续跟踪FragmentManagerImpl</p><h2 id="FragmentManagerImpl-moveToState"><a href="#FragmentManagerImpl-moveToState" class="headerlink" title="FragmentManagerImpl#moveToState"></a>FragmentManagerImpl#moveToState</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitStyle, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHost == <span class="keyword">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No activity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!always &amp;&amp; mCurState == newState) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurState = newState;</span><br><span class="line">    <span class="keyword">if</span> (mActive != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> loadersRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历所有Active状态的Fragment，改变所有Fragment的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">            Fragment f = mActive.get(i);</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//关键代码</span></span><br><span class="line">                moveToState(f, newState, transit, transitStyle, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (f.mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!loadersRunning) &#123;</span><br><span class="line">            startPendingDeferredFragments();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让Activity刷新Menu</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class="keyword">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class="line">            mHost.onInvalidateOptionsMenu();</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置最新的mCurState状态，通过上面的分析，我们知道newState等于Fragment.RESUMED。遍历mActive列表中保存的Fragment，改变Fragment状态，这里又调用了一个<code>moveToState</code>方法，这个方法就是真正回调Fragment生命周期的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> keepActive)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fragments被detach或Fragment没有添加到mAdded列表的话，设置目标Fragment的新状态为CREATED状态，此次分析中不会进入这个分支</span></span><br><span class="line">    <span class="keyword">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        newState = Fragment.CREATED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此次分析中f.mRemoving为false</span></span><br><span class="line">    <span class="keyword">if</span> (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">        <span class="comment">// While removing a fragment, we can't change it to a higher state.</span></span><br><span class="line">        newState = f.mState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否延时启动</span></span><br><span class="line">    <span class="keyword">if</span> (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt; newState) &#123;</span><br><span class="line">        <span class="comment">//此次命中的分支</span></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据Fragment当前的状态，选择case的分支。需要注意的是，这里的switch case是没有break语句的。这种设计可以让Fragment把自身的状态依次推进到目标状态</span></span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                f.mHost = mHost;</span><br><span class="line">                <span class="comment">//mParent是在FragmentActivity的onCreate方法中调用attachHost传进来的，传进来的是空值</span></span><br><span class="line">                f.mParentFragment = mParent;</span><br><span class="line">                f.mFragmentManager = mParent != <span class="keyword">null</span></span><br><span class="line">                        ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();</span><br><span class="line">                f.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//【Fragment生命周期】onAttach回调，里面会把mCalled设置为true</span></span><br><span class="line">                f.onAttach(mHost.getContext());</span><br><span class="line">                <span class="keyword">if</span> (!f.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + f</span><br><span class="line">                            + <span class="string">" did not call through to super.onAttach()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (f.mParentFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//让Activity可以监听到Fragment的attach</span></span><br><span class="line">                    mHost.onAttachFragment(f);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.mParentFragment.onAttachFragment(f);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//f.mRetaining默认为false</span></span><br><span class="line">                <span class="keyword">if</span> (!f.mRetaining) &#123;</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onCreate</span></span><br><span class="line">                    f.performCreate(f.mSavedFragmentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.restoreChildFragmentState(f.mSavedFragmentState, <span class="keyword">true</span>);</span><br><span class="line">                    f.mState = Fragment.CREATED;</span><br><span class="line">                &#125;</span><br><span class="line">                f.mRetaining = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//Fragment是否定义在Layout文件的&lt;fragment&gt;标签中的，本次栗子为代码动态添加Fragment，所以为false</span></span><br><span class="line">                <span class="keyword">if</span> (f.mFromLayout) &#123;</span><br><span class="line">                    <span class="comment">// For fragments that are part of the content view</span></span><br><span class="line">                    <span class="comment">// layout, we need to instantiate the view immediately</span></span><br><span class="line">                    <span class="comment">// and the inflater will take care of adding it.</span></span><br><span class="line">                    f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                            f.mSavedFragmentState), <span class="keyword">null</span>, f.mSavedFragmentState);</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.mView.setSaveFromParentEnabled(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                        f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意，这里没有break</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!f.mFromLayout) &#123;</span><br><span class="line">                        <span class="comment">//开始创建Fragment的view</span></span><br><span class="line">                        ViewGroup container = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (f.mContainerId != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (f.mContainerId == View.NO_ID) &#123;</span><br><span class="line">                                throwException(<span class="keyword">new</span> IllegalArgumentException(<span class="string">""</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//调用Activity的findViewById方法查找控件</span></span><br><span class="line">                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">                            <span class="keyword">if</span> (container == <span class="keyword">null</span> &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                                ......</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mContainer = container;</span><br><span class="line">                        <span class="comment">//关键代码，内部会调用【Fragment生命周期】onCreateView，并返回Fragment中new出的视图</span></span><br><span class="line">                        f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                                f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">                        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            f.mView.setSaveFromParentEnabled(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//设置入场动画</span></span><br><span class="line">                                Animator anim = loadAnimator(f, transit, <span class="keyword">true</span>,</span><br><span class="line">                                        transitionStyle);</span><br><span class="line">                                <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    anim.setTarget(f.mView);</span><br><span class="line">                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);</span><br><span class="line">                                    anim.start();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//把Fragment的view加入到父控件</span></span><br><span class="line">                                container.addView(f.mView);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//【Fragment生命周期】onViewCreated回调</span></span><br><span class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onActivityCreated</span></span><br><span class="line">                    f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    f.mState = Fragment.STOPPED;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STOPPED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto STARTED: "</span> + f);</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onStart</span></span><br><span class="line">                    f.performStart();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onResume</span></span><br><span class="line">                    f.performResume();</span><br><span class="line">                    <span class="comment">// Get rid of this in case we saved it and never needed it.</span></span><br><span class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">                    f.mSavedViewState = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="comment">//state降级处理</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (f.mState != newState) &#123;</span><br><span class="line">        f.mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑还是比较长，我把注释写在代码里了。可以看到，这个代码写得很巧妙，通过switch case控制，可以一层一层地把Fragment的生命周期推进下去，比如当前fragnemt的state是<code>Fragment.STARTED</code>，那么它就只会执行performResume，如果Fragment的状态是<code>Fragment.INITIALIZING</code>，那么就会从switch的最开始依次执行下来，把Fragment的生命周期onAttach–&gt;onResume依次调用。<br>简要说明下上面的代码：</p><ul><li>mHost是FragmentHostCallback抽象类的实例，它的实现类是Activity的HostCallbacks</li><li>mParent为null</li><li>mHost.getContext()获取的context就是宿主Activity实例</li><li>Fragment中创建的View会自动通过container.addView(f.mView)添加到父控件中</li></ul><p>很多Fragment的生命周期是通过Fragment的performXxx()方法去调用的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">performCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onActivityCreated(savedInstanceState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onStart();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onResume();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment状态的降级操作"><a href="#Fragment状态的降级操作" class="headerlink" title="Fragment状态的降级操作"></a>Fragment状态的降级操作</h2><p>有些童鞋们可能会有疑问，上面只分析到了onAttach-&gt;onResume生命周期的回调，那onPause、onDestroy等方法又是什么时候执行的呢？我们再看下刚才的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.mState &lt; newState) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">    <span class="comment">//state降级处理</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案就是在else if分支里面，比如当Acivity锁屏的时候，就Activity生命周期会自动回调onPause，从而触发dispatchPause，在里面调用moveToState(Fragment.STARTED, false);<br>由于Fragment当前的状态是RESUMED状态，大于newState，所以就会走else if的分支，触发相应的生命周期方法。else if分支的逻辑和state升级的差不多，这里就再进行分析了</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="http://image.hanschen.site/master/2019-9-2-11-26-16.png" alt="2019-9-2-11-26-16.png"><br>最后，放张官网上公布的Fragment生命周期图，通过代码分析，我们发现代码的中生命周期的调用顺序和图中确实是一致的</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大致地从源码的角度分析了Fragment创建、生命周期回调的过程，如果读者对Fragment的<code>remove</code>、<code>replace</code>、<code>hide</code>、<code>detach</code>、<code>attach</code>等操作有兴趣的话，可以自行分析，核心代码主要在BackStackRecord类的run方法以及FragmentManagerImpl的moveToState方法中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Fragment&lt;/code&gt;表示 Activity 中的行为或用户界面部分。您可以将多个 Fragment 组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个 Fragment。您可以将 Fragment 视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除 Fragment。&lt;br&gt;Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有 Fragment 也会暂停；当 Activity 被销毁时，所有 Fragment 也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个 Fragment，如添加或移除它们。 当您执行此类 Fragment 事务时，您也可以将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生 Fragment 事务的记录。 返回栈让用户可以通过按返回按钮撤消 Fragment 事务（后退）。&lt;/p&gt;
&lt;p&gt;当您将 Fragment 作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且 Fragment 会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明Fragment，将其作为 &lt;code&gt;&amp;lt;fragment&amp;gt;&lt;/code&gt; 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，Fragment 并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的 Fragment 用作 Activity 的不可见工作线程。&lt;/p&gt;
&lt;p&gt;本文将通过分析源码，对 Fragment 的创建、销毁以及生命周期做一个更深入的认识。&lt;/p&gt;
&lt;p&gt;建议读者在看这篇文章的时候，先看下&lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/53132952&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fragment事务管理源码分析&lt;/a&gt;，对Fragment管理类先有一个比较清楚的认识。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Fragment" scheme="http://blog.hanschen.site/tags/Fragment/"/>
    
      <category term="源码分析" scheme="http://blog.hanschen.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Fragment事务管理源码分析</title>
    <link href="http://blog.hanschen.site/2016/11/11/fragment-transaction/"/>
    <id>http://blog.hanschen.site/2016/11/11/fragment-transaction/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Fragment使用中，有时候需要对Fragment进行<code>add</code>、<code>remove</code>、<code>show</code>、<code>hide</code>、<code>replace</code>等操作来进行Fragment的显示隐藏等管理，这些管理是通过<code>FragmentTransaction</code>进行事务管理的。事务管理是对于一系列操作进行管理，一个事务包含一个或多个操作命令，是逻辑管理的工作单元。一个事务开始于第一次执行操作语句，结束于Commit。通俗地将，就是把多个操作缓存起来，等调用commit的时候，统一批处理。下面会对Fragmeng的事务管理做一个代码分析</p><a id="more"></a><h1 id="分析入口"><a href="#分析入口" class="headerlink" title="分析入口"></a>分析入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示Fragment，如果Fragment已添加过，则直接show，否则构造一个Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containerViewId 容器控件id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz             Fragment类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(@IdRes <span class="keyword">int</span> containerViewId, Class&lt;? extends Fragment&gt; clz)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = getFragmentManager();</span><br><span class="line">    FragmentTransaction ft = fm.beginTransaction();<span class="comment">//开始事务管理</span></span><br><span class="line">    Fragment f;</span><br><span class="line">    <span class="keyword">if</span> ((f = fm.findFragmentByTag(clz.getName())) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f = clz.newInstance();</span><br><span class="line">            ft.add(containerViewId, f, clz.getName());<span class="comment">//添加操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ft.show(f);<span class="comment">//添加操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ft.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个简单的显示Fragment的栗子，简单判断一下Fragment是否已添加过，添加过就直接show，否则构造一个Fragment，最后提交事务。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="FragmentManager"><a href="#FragmentManager" class="headerlink" title="FragmentManager"></a>FragmentManager</h2><p><img src="http://image.hanschen.site/master/2019-9-2-11-19-20.png" alt="2019-9-2-11-19-20.png"><br>上图是获取FragmentManager的大体过程</p><p>要管理Fragment事务，首先是需要拿到FragmentManager，在Activity中可以通过<code>getFragmentManager()</code>方法获取(使用兼容包的话，通过<code>FragmentActivity#getSupportFragmentManager()</code>)，在这里我们就不对兼容包进行分析了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the FragmentManager for interacting with fragments associated</span></span><br><span class="line"><span class="comment"> * with this activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragments.getFragmentManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FragmentManager是一个抽象类，它是通过mFragments.getFragmentManager()来获取的，mFragments是FragmentController对象，它通过<code>FragmentController.createController(new HostCallbacks())</code>生成，这是一个静态工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FragmentController <span class="title">createController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FragmentController(callbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面直接new了一个FragmentController对象，注意FragmentController的构造方法需要传入一个<code>FragmentHostCallback</code></p><h2 id="FragmentController构造方法"><a href="#FragmentController构造方法" class="headerlink" title="FragmentController构造方法"></a>FragmentController构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FragmentHostCallback&lt;?&gt; mHost;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FragmentController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">    mHost = callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法很简单，传入了一个FragmentHostCallback实例</p><h2 id="FragmentController-getFragmentManager"><a href="#FragmentController-getFragmentManager" class="headerlink" title="FragmentController#getFragmentManager"></a>FragmentController#getFragmentManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mHost.getFragmentManagerImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用了mHost的getFragmentManagerImpl方法，希望童鞋们没有被绕晕，mHost是一个FragmentHostCallback实例，那我们回过头来看看它传进来的地方</p><h2 id="FragmentHostCallback"><a href="#FragmentHostCallback" class="headerlink" title="FragmentHostCallback"></a>FragmentHostCallback</h2><p>这个FragmentHostCallback是一个抽象类，我们可以看到，在Activity中是传入了 <code>Activity#HostCallbacks</code>内部类，这个就是FragmentHostCallback的实现类</p><h2 id="FragmentHostCallback-getFragmentManagerImpl"><a href="#FragmentHostCallback-getFragmentManagerImpl" class="headerlink" title="FragmentHostCallback#getFragmentManagerImpl"></a>FragmentHostCallback#getFragmentManagerImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FragmentManagerImpl mFragmentManager = <span class="keyword">new</span> FragmentManagerImpl();</span><br><span class="line"><span class="function">FragmentManagerImpl <span class="title">getFragmentManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到FragmentManager的真身<code>FragmentManagerImpl</code>了</p><h2 id="FragmentManagerImpl-beginTransaction"><a href="#FragmentManagerImpl-beginTransaction" class="headerlink" title="FragmentManagerImpl#beginTransaction"></a>FragmentManagerImpl#beginTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，所谓的FragmentTransaction其实就是一个BackStackRecord。到现在，FragmentManager和FragmentTransaction我们都找到了。下图就是各个类之间的关系：<br><img src="http://image.hanschen.site/master/2019-9-2-11-20-42.png" alt="2019-9-2-11-20-42.png"></p><p>下面开始真正的事务管理分析，我们先选择一个事务add来进行分析</p><h2 id="FragmentTransaction-add"><a href="#FragmentTransaction-add" class="headerlink" title="FragmentTransaction#add"></a>FragmentTransaction#add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fragment的FragmentManagerImpl，mManager其实就是Activity#HostCallbacks中的成员变量</span></span><br><span class="line">    fragment.mFragmentManager = mManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fragment的tag</span></span><br><span class="line">    <span class="keyword">if</span> (tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mTag != <span class="keyword">null</span> &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mTag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containerViewId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (containerViewId == View.NO_ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mFragmentId != <span class="number">0</span> &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置fragment的mContainerId以及mFragmentId</span></span><br><span class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个操作</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到链表的最后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    op.enterAnim = mEnterAnim;</span><br><span class="line">    op.exitAnim = mExitAnim;</span><br><span class="line">    op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">    op.popExitAnim = mPopExitAnim;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add的操作步骤为：</p><ol><li>设置fragment的FragmentManagerImpl</li><li>设置fragment的tag</li><li>设置fragment的mContainerId以及mFragmentId</li><li>插入一个类型为OP_ADD的操作到链表最后</li></ol><p>这里用到了一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    Op next;<span class="comment">//下一操作节点</span></span><br><span class="line">    Op prev;<span class="comment">//上一操作节点</span></span><br><span class="line">    <span class="keyword">int</span> cmd;<span class="comment">//操作类型，可选有：OP_NULL|OP_ADD|OP_REPLACE|OP_REMOVE|OP_HIDE|OP_SHOW|OP_DETACH|OP_ATTACH</span></span><br><span class="line">    Fragment fragment;<span class="comment">//操作的Fragment对象</span></span><br><span class="line">    <span class="keyword">int</span> enterAnim;<span class="comment">//入场动画</span></span><br><span class="line">    <span class="keyword">int</span> exitAnim;<span class="comment">//出场动画</span></span><br><span class="line">    <span class="keyword">int</span> popEnterAnim;<span class="comment">//弹入动画</span></span><br><span class="line">    <span class="keyword">int</span> popExitAnim;<span class="comment">//弹出动画</span></span><br><span class="line">    ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个操作链表节点。所有add、remove、hide等事物最终会形成一个操作链</p><h2 id="FragmentTransaction-commit"><a href="#FragmentTransaction-commit" class="headerlink" title="FragmentTransaction#commit"></a>FragmentTransaction#commit</h2><p>等所有操作都插入后，最后我们需要调用FragmentTransaction的commit方法，操作才会真正地执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commitInternal(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//防止重复commit</span></span><br><span class="line">    <span class="keyword">if</span> (mCommitted) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DEBUG代码统统不管</span></span><br><span class="line">    <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">"Commit: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        LogWriter logw = <span class="keyword">new</span> LogWriter(Log.VERBOSE, TAG);</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(logw, <span class="keyword">false</span>, <span class="number">1024</span>);</span><br><span class="line">        dump(<span class="string">"  "</span>, <span class="keyword">null</span>, pw, <span class="keyword">null</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有调用了addToBackStack方法之后，这个标记才会为true</span></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入事物队列</span></span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FragmentManagerImpl-enqueueAction"><a href="#FragmentManagerImpl-enqueueAction" class="headerlink" title="FragmentManagerImpl#enqueueAction"></a>FragmentManagerImpl#enqueueAction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds an action to the queue of pending actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action the action to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowStateLoss whether to allow loss of state information</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the activity has been destroyed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!allowStateLoss) &#123;</span><br><span class="line">        checkStateLoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDestroyed || mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Activity has been destroyed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingActions.add(action);</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">            mHost.getHandler().post(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把操作添加到<code>mPendingActions</code>列表里去。并通过mHost.getHandler()获取Handler发送执行请求。从上面的分析知道，mHost就是Activity的HostCallbacks，构造方法中把Activity的mHandler传进去了，这里执行的<code>mHost.getHandler()</code>获取到的也就是Activity中的mHandler，这样做是因为需要在主线程中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br></pre></td></tr></table></figure><p>再看看mExecCommit中做了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Runnable mExecCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only call from main thread!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execPendingActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExecutingActions) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive entry to executePendingTransactions"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次检测是否主线程</span></span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() != mHost.getHandler().getLooper()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Must be called from main thread of process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numActions;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//参数检测</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span> || mPendingActions.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            numActions = mPendingActions.size();</span><br><span class="line">            <span class="keyword">if</span> (mTmpActions == <span class="keyword">null</span> || mTmpActions.length &lt; numActions) &#123;</span><br><span class="line">                mTmpActions = <span class="keyword">new</span> Runnable[numActions];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mPendingActions.toArray(mTmpActions);</span><br><span class="line">            mPendingActions.clear();</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mExecutingActions = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//遍历执行待处理的事务操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numActions; i++) &#123;</span><br><span class="line">            mTmpActions[i].run();</span><br><span class="line">            mTmpActions[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutingActions = <span class="keyword">false</span>;</span><br><span class="line">        didSomething = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doPendingDeferredStart();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入了事物之后，就是在主线程中把需要处理的事务统一处理，处理事务是通过执行<code>mTmpActions[i].run()</code>进行的，这个mTmpActions[i]就是前面我们通过enqueueAction方法插入的BackStackRecord，童鞋们可能没注意到，它可是一个Runnable，我们来看看它的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = FragmentManagerImpl.TAG;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜兜转转，我们又回到了BackStackRecord</p><h2 id="BackStackRecord-run"><a href="#BackStackRecord-run" class="headerlink" title="BackStackRecord#run"></a>BackStackRecord#run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line">        beginTransition(firstOutFragments, lastInFragments, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表，根据cmd事务类型依次处理事务</span></span><br><span class="line">    Op op = mHead;</span><br><span class="line">    <span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REPLACE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                <span class="keyword">int</span> containerId = f.mContainerId;</span><br><span class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        Fragment old = mManager.mAdded.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (old == f) &#123;</span><br><span class="line">                                op.fragment = f = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (op.removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                &#125;</span><br><span class="line">                                op.removed.add(old);</span><br><span class="line">                                old.mNextAnim = op.exitAnim;</span><br><span class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mManager.removeFragment(old, mTransition, mTransitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f.mNextAnim = op.enterAnim;</span><br><span class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.removeFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.hideFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.showFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.detachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.attachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">            mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，提交的事务就被真正执行了，我们知道，即使commit了事务之后，也不是同步执行的，是通过Handler发送到主线程执行的。</p><p>所有事务的处理都是在run方法里面执行，但是我们留意到，想要搞清楚add、remove等事务背后真正做了什么，还需要深入了解FragmentManagerImpl。</p><p>本文主要讲解Fragment事务的流程，FragmentManagerImpl的分析准备放到下一篇分析文章<a href="http://blog.csdn.net/shensky711/article/details/53171248" target="_blank" rel="noopener">Fragment源码分析</a>中，相信通过分析之后，就可以对Fragment的生命周期也有一个很好的认识了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在Fragment使用中，有时候需要对Fragment进行&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;show&lt;/code&gt;、&lt;code&gt;hide&lt;/code&gt;、&lt;code&gt;replace&lt;/code&gt;等操作来进行Fragment的显示隐藏等管理，这些管理是通过&lt;code&gt;FragmentTransaction&lt;/code&gt;进行事务管理的。事务管理是对于一系列操作进行管理，一个事务包含一个或多个操作命令，是逻辑管理的工作单元。一个事务开始于第一次执行操作语句，结束于Commit。通俗地将，就是把多个操作缓存起来，等调用commit的时候，统一批处理。下面会对Fragmeng的事务管理做一个代码分析&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Fragment" scheme="http://blog.hanschen.site/tags/Fragment/"/>
    
      <category term="事务管理" scheme="http://blog.hanschen.site/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="transaction" scheme="http://blog.hanschen.site/tags/transaction/"/>
    
      <category term="源码分析" scheme="http://blog.hanschen.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>java动态代理</title>
    <link href="http://blog.hanschen.site/2016/10/20/java-proxy/"/>
    <id>http://blog.hanschen.site/2016/10/20/java-proxy/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>动态代理是java的一大特性，动态代理的优势就是实现无侵入式的代码扩展。它可以增强我们原有的方法，比如常用的日志监控,添加缓存等，也可以实现方法拦截，通过代理方法修改原方法的参数和返回值等。<br>要了解动态代理，我们需要先看看什么是静态代理</p><a id="more"></a><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>首先你有一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">doSomething</span><span class="params">(String input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口有一个原始的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiImpl</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input + <span class="string">"原始方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了，有一个新的需求，我需要在所有调用<code>doSomething</code>的地方都添加一个log，那怎么办呢？我们当然可以在原有代码上直接加上log，但是ApiImpl里面的log真的是那段代码需要的吗？如果不修改原有代码，能不能实现？当然可以，如，我们添加一个代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiProxy</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiProxy</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过ApiProxy我们就是实现静态代理，这里只是简单的添加了log，我们完全可以在ApiProxy的doSomething方法里面，篡改输入参数input以及返回值，从而做一些坏事~</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在上面静态代理例子中，我们已经实现了代理的功能，那为何还需要动态代理呢？设想一下以下两种情况</p><ul><li>如果Api接口类中有100个方法，需要为每个方法都添加log</li><li>项目中有100个类，需要为每个类的方法都添加log</li></ul><p>对于第一种情况，如果使用静态代理，那就只能这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiProxy</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiProxy</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething1</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething1(input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为每个方法添加实现......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于第二种情况，就只能新建100个代理类了。这种处理方式肯定不是我们喜欢的，怎么优雅地去解决了？动态代理这时候终于可以上场了。</p><p>JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了，比如:</p><ol><li><p>实现InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiHandler</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法会在proxy实例调用方法的时候回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader loader = Api.class.getClassLoader();<span class="comment">//加载代理类的ClassLoader</span></span><br><span class="line">    Class[] interfaces = <span class="keyword">new</span> Class[]&#123;Api.class&#125;;<span class="comment">//需要代理的接口</span></span><br><span class="line">    Api proxy = (Api) Proxy.newProxyInstance(loader, interfaces, <span class="keyword">new</span> ApiHandler(<span class="keyword">new</span> ApiImpl()));<span class="comment">//创建代理对象</span></span><br><span class="line">    proxy.doSomething(<span class="string">"test"</span>);<span class="comment">//会调用ApiHandler的invoke方法</span></span><br><span class="line">    proxy.doSomething1(<span class="string">"test"</span>);<span class="comment">//会调用ApiHandler的invoke方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样，一个动态代理就完成了，但这里有个需要注意的，动态代理只能代理接口，也就是说interfaces数组里面，只能放接口Class</p><h1 id="代理Hook"><a href="#代理Hook" class="headerlink" title="代理Hook"></a>代理Hook</h1><p>代理有比原始对象更强大的能力，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。<br>首先我们得找到被Hook的对象，也就是Hook点；什么样的对象比较适合Hook呢？<strong>静态变量和单例</strong>；在一个进程之内，静态变量和单例变量是不容易发生变化的，所以容易定位，而普通的对象则要么无法标志，要么容易改变，我们根据这个原则找到所谓的Hook点。<br>一般Hook的步骤有：</p><ol><li>寻找Hook点，如静态变量或单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。</li><li>选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib</li><li>用代理对象替换原始对象，如果没有公开是geter/setter方法，可以使用反射</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;动态代理是java的一大特性，动态代理的优势就是实现无侵入式的代码扩展。它可以增强我们原有的方法，比如常用的日志监控,添加缓存等，也可以实现方法拦截，通过代理方法修改原方法的参数和返回值等。&lt;br&gt;要了解动态代理，我们需要先看看什么是静态代理&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://blog.hanschen.site/tags/java/"/>
    
      <category term="proxy" scheme="http://blog.hanschen.site/tags/proxy/"/>
    
      <category term="动态代理" scheme="http://blog.hanschen.site/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android分包MultiDex源码分析</title>
    <link href="http://blog.hanschen.site/2016/10/18/multidex/"/>
    <id>http://blog.hanschen.site/2016/10/18/multidex/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2021-10-21T01:42:39.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android开发者应该都遇到了64K最大方法数限制的问题，针对这个问题，google也推出了multidex分包机制，在生成apk的时候，把整个应用拆成n个dex包（classes.dex、classes2.dex、classes3.dex），每个dex不超过64k个方法。使用multidex，在5.0以前的系统，应用安装时只安装main dex（包含了应用启动需要的必要class），在应用启动之后，需在Application的<code>attachBaseContext</code>中调用<code>MultiDex.install(base)</code>方法，在这时候才加载第二、第三…个dex文件，从而规避了64k问题。<br>当然，在<code>attachBaseContext</code>方法中直接install启动second dex会有一些问题，比如install方法是一个同步方法，当在主线程中加载的dex太大的时候，耗时会比较长，可能会触发ANR。不过这是另外一个问题了，解决方法可以参考：<a href="http://blog.csdn.net/shensky711/article/details/52329035" target="_blank" rel="noopener">Android最大方法数和解决方案</a> <a href="http://blog.csdn.net/shensky711/article/details/52329035。" target="_blank" rel="noopener">http://blog.csdn.net/shensky711/article/details/52329035。</a></p><p>本文主要分析的是<code>MultiDex.install()</code>到底做了什么，如何把secondary dexes中的类动态加载进来。</p><a id="more"></a><h1 id="MultiDex使用到的路径解析"><a href="#MultiDex使用到的路径解析" class="headerlink" title="MultiDex使用到的路径解析"></a>MultiDex使用到的路径解析</h1><ul><li>ApplicationInfo.sourceDir:apk的安装路径，如/data/app/com.hanschen.multidex-1.apk</li><li>Context.getFilesDir()：返回<code>/data/data/&lt;packagename&gt;/files</code>目录，一般通过openFileOutput方法输出文件到该目录</li><li>ApplicationInfo.dataDir: 返回<code>/data/data/&lt;packagename&gt;</code>目录</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="代码入口"><a href="#代码入口" class="headerlink" title="代码入口"></a>代码入口</h2><p>代码入口很简单，简单粗暴，就调用了一个静态方法<code>MultiDex.install(base);</code>，传入一个Context对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MultiDex-install分析"><a href="#MultiDex-install分析" class="headerlink" title="MultiDex.install分析"></a>MultiDex.install分析</h2><p>下面是主要的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install"</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_VM_MULTIDEX_CAPABLE) &#123;</span><br><span class="line">        <span class="comment">//VM版本大于2.1时，IS_VM_MULTIDEX_CAPABLE为true，这时候MultiDex.install什么也不用做，直接返回。因为大于2.1的VM会在安装应用的时候，就把多个dex合并到一块</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//Multi dex最小支持的SDK版本为4</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + VERSION.SDK_INT + <span class="string">" is unsupported. Min SDK version is "</span> + <span class="number">4</span> + <span class="string">"."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationInfo e = getApplicationInfo(context);</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set var2 = installedApk;</span><br><span class="line">            <span class="keyword">synchronized</span> (installedApk) &#123;</span><br><span class="line">                String apkPath = e.sourceDir;</span><br><span class="line">                <span class="comment">//检测应用是否已经执行过install()了，防止重复install</span></span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                installedApk.add(apkPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取ClassLoader，后面会用它来加载second dex</span></span><br><span class="line">                DexClassLoader classLoader;</span><br><span class="line">                ClassLoader loader;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    loader = context.getClassLoader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//清空目录：/data/data/&lt;packagename&gt;/files/secondary-dexes/，其实我没搞明白这个的作用，因为从后面的代码来看，这个目录是没有使用到的</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clearOldDexDir(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File dexDir = <span class="keyword">new</span> File(e.dataDir, <span class="string">"code_cache/secondary-dexes"</span>);</span><br><span class="line">                <span class="comment">//把dex文件缓存到/data/data/&lt;packagename&gt;/code_cache/secondary-dexes/目录，[后有详细分析]</span></span><br><span class="line">                List files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    <span class="comment">//进行安装，[后有详细分析]</span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//文件无效，从apk文件中再次解压secondary dex文件后进行安装</span></span><br><span class="line">                    files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!checkValidZipFiles(files)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + var11.getMessage() + <span class="string">")."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要逻辑整理如下：</p><ol><li>VM版本检测，如果大于2.1就什么都不做(系统在安装应用的时候已经帮我们把dex合并了)，如果系统SDK版本小于4就抛出运行时异常</li><li>把apk中的secondary dexes解压到缓存目录，并把这些缓存读取出来。应用第二次启动的时候，会尝试从缓存目录中读取，除非读取出的文件校验失败，否则不再从apk中解压dexes</li><li>根据当前的SDK版本，执行不同的安装方法</li></ol><p>先来看看<code>MultiDexExtractor.load(context, e, dexDir, false)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压apk文件中的classes2.dex、classes3.dex等文件解压到dexDir目录中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir      解压目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceReload 是否需要强制从apk文件中解压，否的话会直接读取旧文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 解压后的文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ApplicationInfo applicationInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                       File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line">    List files;</span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从缓存目录中直接查找缓存文件，跳过解压</span></span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//把apk中的secondary dex文件解压到缓存目录，并把解压后的文件返回</span></span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        <span class="comment">//把解压信息保存到sharedPreferences中</span></span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断以下是否需要强制从apk文件中解压，再进行下CRC校验，如果不需要从apk重新解压，就直接从缓存目录中读取已解压的文件返回，否则解压apk中的classes文件到缓存目录，再把相应的文件返回。这个方法再往下的分析就不贴出来了，不复杂，大家可以自己去看看。读取后会把解压信息保存到sharedPreferences中，里面会保存时间戳、CRC校验和dex数量。</p><p>得到dex文件列表后，要做的就是把dex文件关联到应用，这样应用findclass的时候才能成功。这个主要是通过<code>installSecondaryDexes</code>方法来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安装dex文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir 缓存目录，用以存放opt之后的dex文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> files  需要安装的dex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          List&lt;File&gt; files)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//对不同版本的SDK做不同处理</span></span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            MultiDex.V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            MultiDex.V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MultiDex.V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于不同的SDK版本，分别采用了不同的处理方法，我们主要分析SDK&gt;=19的情况，其他情况大同小异，读者可以自己去分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">V19</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安装dex文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader                     类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalClassPathEntries 需要安装的dex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory         缓存目录，用以存放opt之后的dex文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                                File optimizedDirectory)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取ClassLoader对象中的pathList属性，其实是ClassLoader的父类BaseDexClassLoader中的成员</span></span><br><span class="line">        Field pathListField = MultiDex.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        <span class="comment">//通过属性获取该属性的值，该属性的类型是DexPathList</span></span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line"></span><br><span class="line">        ArrayList suppressedExceptions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//通过反射调用dexPathList的makeDexElements返回Element对象数组。方法里面会读取每一个输入文件，生成DexFile对象，并将其封装进Element对象</span></span><br><span class="line">        Object[] elements = makeDexElements(dexPathList, <span class="keyword">new</span> ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将elements数组跟dexPathList对象的dexElements数组合并，并把合并后的数组作为dexPathList新的值</span></span><br><span class="line">        MultiDex.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, elements);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator suppressedExceptionsField = suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (suppressedExceptionsField.hasNext()) &#123;</span><br><span class="line">                IOException dexElementsSuppressedExceptions = (IOException) suppressedExceptionsField.next();</span><br><span class="line">                Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Exception in makeDexElement"</span>, dexElementsSuppressedExceptions);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field suppressedExceptionsField1 = MultiDex.findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions1 = (IOException[]) ((IOException[]) suppressedExceptionsField1.get(loader));</span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions1 = (IOException[]) suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions</span><br><span class="line">                        .size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined = <span class="keyword">new</span> IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions1.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions1, <span class="number">0</span>, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions1.length);</span><br><span class="line">                dexElementsSuppressedExceptions1 = combined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            suppressedExceptionsField1.set(loader, dexElementsSuppressedExceptions1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(Object dexPathList,</span><br><span class="line">                                            ArrayList&lt;File&gt; files,</span><br><span class="line">                                            File optimizedDirectory,</span><br><span class="line">                                            ArrayList&lt;IOException&gt; suppressedExceptions) <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        Method makeDexElements = MultiDex.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, <span class="keyword">new</span> Class[]&#123;ArrayList.class, File.class, ArrayList.class&#125;);</span><br><span class="line">        <span class="keyword">return</span> (Object[]) ((Object[]) makeDexElements.invoke(dexPathList, <span class="keyword">new</span> Object[]&#123;files, optimizedDirectory, suppressedExceptions&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android中，有两个ClassLoader，分别是<code>DexPathList</code>和<code>PathClassLoader</code>，它们的父类都是<code>BaseDexClassLoader</code>，DexPathList和PathClassLoader的实现都是在BaseDexClassLoader之中，而BaseDexClassLoader的实现又基本是通过调用DexPathList的方法完成的。DexPathList里面封装了加载dex文件为DexFile对象（调用了native方法，有兴趣的童鞋可以继续跟踪下去）的方法。<br>上述代码中的逻辑如下：</p><ol><li>通过反射获取pathList对象</li><li>通过pathList把输入的dex文件输出为elements数组，elements数组中的元素封装了DexFile对象</li><li>把新输出的elements数组合并到原pathList的dexElements数组中</li><li>异常处理</li></ol><p>当把dex文件加载到pathList的dexElements数组之后，整个multidex.install基本上就完成了。<br>但可能还有些童鞋还会有些疑问，仅仅只是把Element数组合并到ClassLoader就可以了吗？还是没有找到加载类的地方啊？那我们再继续看看，当用到一个类的时候，会用ClassLoader去加载一个类，加载类会调用类加载器的findClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="comment">//调用pathList的findClass方法</span></span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是继续跟踪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历dexElements数组</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line"></span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//继续跟踪会发现调用的是一个native方法</span></span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在就清晰了，当加载一个类的时候，会遍历dexElements数组，通过native方法从Element元素中加载类名相应的类</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到最后，总结整个multidex.install流程，其实很简单，就做了一件事情，把apk中的secondary dex文件通过ClassLoader转换成Element数组，并把输出的数组合与ClassLoader的Element数组合并。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Android开发者应该都遇到了64K最大方法数限制的问题，针对这个问题，google也推出了multidex分包机制，在生成apk的时候，把整个应用拆成n个dex包（classes.dex、classes2.dex、classes3.dex），每个dex不超过64k个方法。使用multidex，在5.0以前的系统，应用安装时只安装main dex（包含了应用启动需要的必要class），在应用启动之后，需在Application的&lt;code&gt;attachBaseContext&lt;/code&gt;中调用&lt;code&gt;MultiDex.install(base)&lt;/code&gt;方法，在这时候才加载第二、第三…个dex文件，从而规避了64k问题。&lt;br&gt;当然，在&lt;code&gt;attachBaseContext&lt;/code&gt;方法中直接install启动second dex会有一些问题，比如install方法是一个同步方法，当在主线程中加载的dex太大的时候，耗时会比较长，可能会触发ANR。不过这是另外一个问题了，解决方法可以参考：&lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/52329035&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android最大方法数和解决方案&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/52329035。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/shensky711/article/details/52329035。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要分析的是&lt;code&gt;MultiDex.install()&lt;/code&gt;到底做了什么，如何把secondary dexes中的类动态加载进来。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="MultiDex" scheme="http://blog.hanschen.site/tags/MultiDex/"/>
    
      <category term="分包" scheme="http://blog.hanschen.site/tags/%E5%88%86%E5%8C%85/"/>
    
  </entry>
  
</feed>
