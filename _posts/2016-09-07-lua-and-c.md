---
layout: post
title:  Lua和C交互的简易教程
excerpt: 要理解Lua和C++交互，首先要理解Lua堆栈。简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出
---

> 转载请标明出处，本文出自:【HansChen的博客 [http://blog.csdn.net/shensky711](http://blog.csdn.net/shensky711)】

# Lua栈
要理解Lua和C++交互，首先要理解Lua堆栈。简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出

在Lua中，Lua堆栈就是一个struct，堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶,如图：
![这里写图片描述](http://img.blog.csdn.net/20160907113459731)

入栈的数据类型包括数值, 字符串, 指针, talbe, 闭包等, 下面是一个栈的例子:
![这里写图片描述](http://img.blog.csdn.net/20160907113515543)

执行下面的代码就可以让你的lua栈上呈现图中的情况:
```
// 创建并压入一个闭包
lua_pushcclosure(L, func, 0);

// 新建并压入一个表
lua_createtable(L, 0, 0);

// 压入一个数字
lua_pushnumber(L, 100);

// 压入一个字符串
lua_pushstring(L, "hello，lua");
```

这里要说明的是, 你压入的类型有数值, 字符串, 表和闭包[在c中看来是不同类型的值], 但是最后都是统一用TValue这种数据结构来保存的,下面用图简单的说明一下这种数据结构:
![这里写图片描述](http://img.blog.csdn.net/20160907113528106)


TValue结构对应于lua中的所有数据类型, 是一个{值, 类型} 结构,这就lua中动态类型的实现, 它把值和类型绑在一起, 用tt记录value的类型, value是一个联合结构, 由Value定义, 可以看到这个联合有四个域, 先说明简单的

 - p -- 可以存一个指针, 实际上是lua中的light userdata结构
 - n -- 所有的数值存在这里, 不过是int , 还是float
 - b -- Boolean值存在这里, 注意, lua_pushinteger不是存在这里, 而是存在n中, b只存布尔
 - gc -- 其他诸如table, thread, closure,string需要内存管理垃圾回收的类型都存在这里,gc是一个指针, 它可以指向的类型由联合体GCObject定义, 从图中可以看出, 有string, userdata, closure, table, proto, upvalue, thread

可以的得出如下结论:

 1. lua中, number, boolean, nil, light userdata四种类型的值是直接存在栈上元素里的, 和垃圾回收无关.
 2. lua中, string, table, closure, userdata, thread存在栈上元素里的只是指针, 他们都会在生命周期结束后被垃圾回收.

# 堆栈的操作
因为Lua与C/C++是通过栈来通信，我们先来看一个最简单的例子:
```
#include <stdio.h>
#include "../lua/lauxlib.h"

int main(int argc, const char *argv[]) {

    //1.创建一个state
    lua_State *L = luaL_newstate();

    //2.入栈操作
    lua_pushstring(L, "I am so cool~");
    lua_pushnumber(L, 20);

    //3.取值操作
    if (lua_isstring(L, 1)) { //这里的index也可以是-2
        printf("[line:%d] lua_tostring(L, 1):%s\n", __LINE__, lua_tostring(L, 1));
    }
    if (lua_isnumber(L, 2)) { //这里的index也可以是-1
        printf("[line:%d] lua_tonumber(L, 2):%f\n", __LINE__, lua_tonumber(L, 2));
    }

    //4.关闭state
    lua_close(L);
    return 0;
}
```

其他一些栈操作：
```
//返回栈顶索引（即栈长度）  
int lua_gettop (lua_State *L); 

//将栈顶设置为一个指定的位置，即修改栈中元素的数量。如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。所以可以用lua_settop(0)来清空栈
void lua_settop (lua_State *L, int idx); 

//新增一个元素到栈顶，值与index位置的值相同
void lua_pushvalue(lua_State *L, int idx);

//移除idx索引上的值，高于index的元素的索引将全部-1  
void lua_remove(lua_State *L, int idx); 

//把栈顶元素挪到index位置，原index位置的元素往栈顶移动
void lua_insert(lua_State *L, int idx); 

//把栈顶元素挪到index位置，并删除原index位置的元素
void lua_replace (lua_State *L, int idx);
```

# C调用Lua
现在有这样一个hello.lua 文件：
```
str = "Hello, Lua !"
table = {name = "hans", id = 123456}

function add(x, y)
	return x + y
end
```

我们写一个main.c来读取它：
```
#include <stdio.h>
#include "../lua/lauxlib.h"

lua_State *load_lua(char *filename) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    //加载脚本并运行
    if (luaL_loadfile(L, filename) || lua_pcall(L, 0, 0, 0)) {
        printf("load Lua script failed: %s\n", lua_tostring(L, -1));
        return NULL;
    }

    return L;
}

int main(int argc, const char *argv[]) {

    char* lua_filename = "E:\\work\\luaJni\\resource\\test.lua";
    lua_State *L = load_lua(lua_filename);
    if (NULL == L) {
        return -1;
    }

    //读取变量
    lua_getglobal(L, "str");
    printf("[line:%d] luaV_tostring(L, -1):%s\n", __LINE__, lua_tostring(L, -1));

    //读取table
    lua_getglobal(L, "table");
    lua_getfield(L, -1, "name");
    printf("[line:%d] lua_tostring(L,-1);:%s\n", __LINE__, lua_tostring(L, -1));

    //调用函数
    lua_getglobal(L, "add"); //读取函数到栈顶
    lua_pushnumber(L, 10); //压入参数
    lua_pushnumber(L, 20);

    if (lua_pcall(L, 2, 1, 0) != 0) {
        printf("lua_pcall failed: %s\n", lua_tostring(L, -1));
        return -1;
    }
    int result = lua_tonumber(L, -1);
    printf("[line:%d] result:%d\n", __LINE__, result);

    //至此，栈中的情况是：
    //=================== 栈顶 ===================
    //  索引  类型      值
    //   4   int：      30
    //   3   string：   hans
    //   2   table:     table
    //   1   string:    Hello, Lua !
    //=================== 栈底 ===================
    lua_close(L);
    return 0;
}
```

知道怎么读取后，我们来看下如何修改上面代码中table的值：
```
//将需要设置的值设置到栈中  
lua_pushstring(L, "Hello，hahaha");  
//将这个值设置到table中（此时table在栈的位置为2）  
lua_setfield(L, 2, "name");
```
我们还可以新建一个table：
```
//创建一个新的table，并压入栈  
lua_newtable(L);  
//往table中设置值  
lua_pushstring(L, "hello, new table !"); //将值压入栈  
lua_setfield(L, -2, "str"); //将值设置到table中，并将hello, new table !出栈
```

需要注意的是：栈操作是基于栈顶的，就是说它只会去操作栈顶的值。
举个比较简单的例子，函数调用流程是先将函数入栈，参数入栈，然后用lua_pcall调用函数，此时栈顶为参数，栈底为函数，所以栈过程大致会是：参数出栈->保存参数->函数出栈->调用函数->返回结果入栈

类似的还有lua_setfield，设置一个表的值，肯定要先将值出栈，保存，再去找表的位置

# Lua调用C
我们可以加入我们自己的函数。函数要遵循规范（可在lua.h中查看）如下：
```
//所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用Lua栈作为参数，所以它可以从栈里面读取任意数量和任意类型的参数。而这个函数的返回值则表示函数返回时有多少返回值被压入Lua栈
typedef int (*lua_CFunction) (lua_State *L);
```

```
--lua_call_c.lua
a, b = getTwoVar('hello, this string is from lua world', 123)
print(a, b)
```
```
/**
 * 定义在lua中可调用的函数，要遵循规范：返回值必须为int，需传入lua_State
 */
int getTwoVar(lua_State *L) {

    dumpStack(L);
    //    =================== 栈顶 ===================
    //    index     type         value
    //    2         number       123.000000
    //    1         string       hello, this string is from lua world
    //    =================== 栈底 ===================
    lua_pushnumber(L, 10);
    lua_pushstring(L, "hello");
    return 2;
}

void lua_call_c() {

    char* lua_filename = "E:\\work\\luaJni\\resource\\lua_call_c.lua";
    lua_State *L = load_lua(lua_filename, FALSE);
    if (NULL == L) {
        return;
    }
    lua_register(L, "getTwoVar", getTwoVar);
    lua_pcall(L, 0, 0, 0);
}
```

还可以使用dll动态链接的方式，把c实现的代码打包成dll
h文件如下：
```
#pragma once  
extern "C" {  
#include "lua.h"  
#include "lualib.h"  
#include "lauxlib.h"  
}  
   
#ifdef LUA_EXPORTS  
#define LUA_API __declspec(dllexport)  
#else  
#define LUA_API __declspec(dllimport)  
#endif  
   
extern "C" LUA_API int luaopen_mLualib(lua_State *L);//定义导出函数
```
C文件如下：
```
#include <stdio.h>  
#include "mLualib.h"  
static int averageFunc(lua_State *L)  
{  
    int n = lua_gettop(L);  
    double sum = 0;  
    int i;  
   
    /* 循环求参数之和 */  
    for (i = 1; i <= n; i++)  
        sum += lua_tonumber(L, i);  
   
    lua_pushnumber(L, sum / n);     //压入平均值  
    lua_pushnumber(L, sum);         //压入和  
   
    return 2;                       //返回两个结果  
}  
   
static int sayHelloFunc(lua_State* L)  
{  
    printf("hello world!");  
    return 0;  
}  
   
static const struct luaL_Reg myLib[] =   
{  
    {"average", averageFunc},  
    {"sayHello", sayHelloFunc},  
    {NULL, NULL}       //数组中最后一对必须是{NULL, NULL}，用来表示结束      
};  
   
int luaopen_mLualib(lua_State *L)  
{  
    luaL_register(L, "ss", myLib);  
    return 1;       // 把myLib表压入了栈中，所以就需要返回1  
}
```

在lua中我们这样子来调用（调用之前记得把dll文件复制到lua文件目录下）：
```
require "mylib"  
local ave,sum = ss.average(1,2,3,4,5)//参数对应堆栈中的数据  
print(ave,sum)  -- 3 15  
ss.sayHello()   -- hello world!
```

至此都发生了什么呢？梳理一下：

 1. 我们编写了averageFunc求平均值和sayHelloFunc函数
 2. 然后把函数封装myLib数组里面，类型必须是luaL_Reg
 3. 由luaopen_mLualib函数导出并在lua中注册这两个函数


实际上当我们在Lua中：
```
require "mLualib"
```
这样子写的时候，Lua会这么干：
```
local path = "mLualib.dll"    
local f = package.loadlib(path,"luaopen_mLualib")   -- 返回luaopen_mLualib函数 
f() 
```
所以当我们在编写一个这样的模块的时候，编写luaopen_xxx导出函数的时候，xxx最好是和项目名一样

# 总结
 - Lua和C++是通过一个虚拟栈来交互的。
 - C调用Lua实际上是：由C先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C
 - Lua调C也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数


本文不涉及lua语法学习，如果有需要，请移步：http://book.luaer.cn/
 

 
 